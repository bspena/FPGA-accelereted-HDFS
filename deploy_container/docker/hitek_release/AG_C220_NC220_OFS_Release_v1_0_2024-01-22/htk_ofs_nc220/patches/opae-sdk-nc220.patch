diff --git a/binaries/fpgadiag/CMakeLists.txt b/binaries/fpgadiag/CMakeLists.txt
index 7562bb5d..db5cd944 100644
--- a/binaries/fpgadiag/CMakeLists.txt
+++ b/binaries/fpgadiag/CMakeLists.txt
@@ -112,7 +112,8 @@ if (OPAE_WITH_PYBIND11)
 
     add_custom_command(
         OUTPUT ${OUTPUT}
-        COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${PYDIST_STAGE_DIR}/build --no-warn-script-location .
+        ##COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${PYDIST_STAGE_DIR}/build --no-warn-script-location .
+        COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${PYDIST_STAGE_DIR}/build .
         COMMAND ${CMAKE_COMMAND} -E touch ${OUTPUT}
         WORKING_DIRECTORY ${PYDIST_STAGE_DIR}
         DEPENDS pyproject.toml setup.py ${PKG_FILES}
diff --git a/binaries/hssi/CMakeLists.txt b/binaries/hssi/CMakeLists.txt
index f2776c0a..9d0cae4e 100644
--- a/binaries/hssi/CMakeLists.txt
+++ b/binaries/hssi/CMakeLists.txt
@@ -29,7 +29,8 @@ file(GLOB_RECURSE PKG_FILES ${CMAKE_CURRENT_SOURCE_DIR}/ethernet/*.py)
 
 add_custom_command(
     OUTPUT ${OUTPUT}
-    COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${CMAKE_CURRENT_SOURCE_DIR}/build --no-warn-script-location .
+    ##COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${CMAKE_CURRENT_SOURCE_DIR}/build --no-warn-script-location .
+    COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${CMAKE_CURRENT_SOURCE_DIR}/build  .
     COMMAND ${CMAKE_COMMAND} -E touch ${OUTPUT}
     WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
     DEPENDS pyproject.toml ${PKG_FILES}
diff --git a/binaries/ofs.uio/CMakeLists.txt b/binaries/ofs.uio/CMakeLists.txt
index 43792725..fd2af38d 100644
--- a/binaries/ofs.uio/CMakeLists.txt
+++ b/binaries/ofs.uio/CMakeLists.txt
@@ -28,7 +28,8 @@ set(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/timestamp)
 
 add_custom_command(
     OUTPUT ${OUTPUT}
-    COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${CMAKE_CURRENT_SOURCE_DIR}/build --no-warn-script-location .
+    ##COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${CMAKE_CURRENT_SOURCE_DIR}/build --no-warn-script-location .
+    COMMAND ${PYTHON_EXECUTABLE} -m pip install --root=${CMAKE_CURRENT_SOURCE_DIR}/build .
     COMMAND ${CMAKE_COMMAND} -E touch ${OUTPUT}
     WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
     DEPENDS pyproject.toml ${PKG_FILES}
diff --git a/binaries/opae.io/opae/io/config.py b/binaries/opae.io/opae/io/config.py
index 7651f95b..e37c95db 100644
--- a/binaries/opae.io/opae/io/config.py
+++ b/binaries/opae.io/opae/io/config.py
@@ -91,12 +91,22 @@ DEFAULT_OPAE_IO_CONFIG = {
   (0x8086, 0xbccf, 0x8086, 0x1770) : {
     'platform': 'Intel Acceleration Development Platform N6000'
   },
+
+
+  #(0x8086, 0xbcce, 0x8086, 0x1771) : {
+  #  'platform': 'Intel Acceleration Development Platform N6001'
+  #},
+  #(0x8086, 0xbccf, 0x8086, 0x1771) : {
+  #  'platform': 'Intel Acceleration Development Platform N6001'
+  #},
+
   (0x8086, 0xbcce, 0x8086, 0x1771) : {
-    'platform': 'Intel Acceleration Development Platform N6001'
+    'platform': 'Intel Open FPGA Stack Platform NC220'
   },
   (0x8086, 0xbccf, 0x8086, 0x1771) : {
-    'platform': 'Intel Acceleration Development Platform N6001'
+    'platform': 'Intel Open FPGA Stack Platform NC220'
   },
+
   (0x8086, 0xbcce, 0x8086, 0x17d4): {
     'platform': 'Intel IPU Platform F2000X-PL'
   },
diff --git a/binaries/qpafilter/nc220_bmc_sensors.yml b/binaries/qpafilter/nc220_bmc_sensors.yml
new file mode 100644
index 00000000..45170ba4
--- /dev/null
+++ b/binaries/qpafilter/nc220_bmc_sensors.yml
@@ -0,0 +1,46 @@
+FPGA Core dts01 Temperature:
+- id: 14
+FPGA Core dts11 Temperature:
+- id: 15
+FPGA Core dts12 Temperature:
+- id: 19
+FPGA Core dts21 Temperature:
+- id: 16
+FPGA Core dts22 Temperature:
+- id: 20
+FPGA Core dts31 Temperature:
+- id: 17
+FPGA Core dts32 Temperature:
+- id: 21
+FPGA Core dts41 Temperature:
+- id: 18
+FPGA Core dts42 Temperature:
+- id: 22
+HSSI_0_0 dts1 Temperature:
+- id: 8
+HSSI_0_1 dts2 Temperature:
+- id: 9
+HSSI_0_1 dts3 Temperature:
+- id: 10
+HSSI_0_1 dts4 Temperature:
+- id: 11
+HSSI_0_1 dts5 Temperature:
+- id: 12
+HSSI_0_1 dts1 Temperature:
+- id: 2
+- id: 3
+  adjustment: -1.5
+- id: 4
+  adjustment: -1.5
+- id: 5
+  adjustment: -1.5
+HSSI_0_1 dts2 Temperature:
+- id: 3
+HSSI_0_1 dts3 Temperature:
+- id: 4
+HSSI_0_1 dts4 Temperature:
+- id: 5
+HSSI_0_1 dts5 Temperature:
+- id: 6
+FPGA Virtual Temperature Sensor 0:
+- id: 0x8000
diff --git a/binaries/qpafilter/qpafilter.py b/binaries/qpafilter/qpafilter.py
index 5325f969..7ae8155d 100755
--- a/binaries/qpafilter/qpafilter.py
+++ b/binaries/qpafilter/qpafilter.py
@@ -585,7 +585,7 @@ def parse_args():
 
     parser.add_argument('-s', '--sensor-file',
                         type=read_sensors, dest='sensor_map',
-                        default='n6000_bmc_sensors.yml',
+                        default='nc220_bmc_sensors.yml',
                         help='BMC sensor to id file')
 
     subparser = parser.add_subparsers()
diff --git a/libraries/CMakeLists.txt b/libraries/CMakeLists.txt
index 6147380c..467f1cd6 100644
--- a/libraries/CMakeLists.txt
+++ b/libraries/CMakeLists.txt
@@ -73,5 +73,6 @@ opae_add_subdirectory(libboard/board_a10gx)
 opae_add_subdirectory(libboard/board_n3000)
 opae_add_subdirectory(libboard/board_d5005)
 opae_add_subdirectory(libboard/board_n6000)
+opae_add_subdirectory(libboard/board_nc220)
 opae_add_subdirectory(libboard/board_n5010)
 opae_add_subdirectory(libboard/board_c6100)
diff --git a/libraries/libboard/board_nc220/CMakeLists.txt b/libraries/libboard/board_nc220/CMakeLists.txt
new file mode 100644
index 00000000..3562ce88
--- /dev/null
+++ b/libraries/libboard/board_nc220/CMakeLists.txt
@@ -0,0 +1,43 @@
+## Copyright(c) 2021-2022, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+opae_add_module_library(TARGET board_nc220
+    SOURCE
+        board_nc220.c
+        board_event_log.c
+        ${opae-test_ROOT}/framework/mock/opae_std.c
+    LIBS
+        ${CMAKE_THREAD_LIBS_INIT}
+        opae-c
+        opaeuio
+        board_common
+    COMPONENT opaeboardlib
+)
+
+target_include_directories(board_nc220
+    PRIVATE
+        ${OPAE_LIB_SOURCE}/libboard/board_common
+)
diff --git a/libraries/libboard/board_nc220/board_event_log.c b/libraries/libboard/board_nc220/board_event_log.c
new file mode 100644
index 00000000..095d026c
--- /dev/null
+++ b/libraries/libboard/board_nc220/board_event_log.c
@@ -0,0 +1,1082 @@
+// Copyright(c) 2021-2022, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <endian.h>
+#include <limits.h>
+#include <time.h>
+#include <ofs/ofs_defs.h>
+#include <opae/fpga.h>
+
+#include "board_event_log.h"
+
+#define BEL_BLOCK_SIZE     0x1000
+#define BEL_BLOCK_COUNT    63
+#define BEL_PTR_OFFSET     (BEL_BLOCK_COUNT * BEL_BLOCK_SIZE)
+#define BEL_PTR_SIZE       4
+#define BEL_LABEL_FMT      "%-*s : "
+
+#define ARRAY_SIZE(a) (sizeof(a)/sizeof(*a))
+
+enum bel_magic {
+	BEL_POWER_ON_STATUS     = 0x53696C12,
+	BEL_TIMEOF_DAY_STATUS   = 0x53696CF0,
+	BEL_MAX10_SEU_STATUS    = 0x53696CBC,
+	BEL_FPGA_SEU_STATUS     = 0x53696CDE,
+	BEL_POWER_OFF_STATUS    = 0x53696C34,
+	BEL_SENSORS_STATE       = 0x53696C56,
+	BEL_SENSORS_STATUS      = 0x53696C78,
+	BEL_PCI_ERROR_STATUS    = 0x53696C9A,
+	BEL_PCI_V1_ERROR_STATUS = 0x53696D12
+};
+
+enum bel_power_regulator {
+	BEL_PWR_REG_IR38062_VOUT = 0,
+	BEL_PWR_REG_IR38062_IOUT,
+	BEL_PWR_REG_IR38062_VIN,
+	BEL_PWR_REG_IR38062_TEMP,
+	BEL_PWR_REG_IR38063_VOUT,
+	BEL_PWR_REG_IR38063_IOUT,
+	BEL_PWR_REG_IR38063_VIN,
+	BEL_PWR_REG_IR38063_TEMP,
+	BEL_PWR_REG_ISL68220_VOUT,
+	BEL_PWR_REG_ISL68220_IOUT,
+	BEL_PWR_REG_ISL68220_VIN,
+	BEL_PWR_REG_ISL68220_TEMP
+};
+
+struct bel_sensor_info {
+	uint32_t id;
+	const char *label;
+	const char *unit;
+	uint32_t resolution;
+};
+
+static struct bel_sensor_info bel_sensor_info[] = {
+	{ .id =  1, .label = "FPGA F-TILE 1 Max Temperature", .unit = "°C", .resolution = 2 },
+	{ .id =  2, .label = "FPGA F-TILE 1 Temperature#1", .unit = "°C", .resolution = 2 },
+	{ .id =  3, .label = "FPGA F-TILE 1 Temperature#2", .unit = "°C", .resolution = 2 },
+	{ .id =  4, .label = "FPGA F-TILE 1 Temperature#3", .unit = "°C", .resolution = 2 },
+	{ .id =  5, .label = "FPGA F-TILE 1 Temperature#4", .unit = "°C", .resolution = 2 },
+	{ .id =  6, .label = "FPGA F-TILE 1 Temperature#5", .unit = "°C", .resolution = 2 },
+	{ .id =  7, .label = "FPGA F-TILE 2 Max Temperature", .unit = "°C", .resolution = 2 },
+	{ .id =  8, .label = "FPGA F-TILE 2 Temperature#1", .unit = "°C", .resolution = 2 },
+	{ .id =  9, .label = "FPGA F-TILE 2 Temperature#2", .unit = "°C", .resolution = 2 },
+	{ .id = 10, .label = "FPGA F-TILE 2 Temperature#3", .unit = "°C", .resolution = 2 },
+	{ .id = 11, .label = "FPGA F-TILE 2 Temperature#4", .unit = "°C", .resolution = 2 },
+	{ .id = 12, .label = "FPGA F-TILE 2 Temperature#5", .unit = "°C", .resolution = 2 },
+	{ .id = 13, .label = "FPGA FABRIC Max Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 14, .label = "FPGA FABRIC DTS#1", .unit = "°C", .resolution = 2 },
+	{ .id = 15, .label = "FPGA FABRIC DTS#2", .unit = "°C", .resolution = 2 },
+	{ .id = 16, .label = "FPGA FABRIC DTS#3", .unit = "°C", .resolution = 2 },
+	{ .id = 17, .label = "FPGA FABRIC DTS#4", .unit = "°C", .resolution = 2 },
+	{ .id = 18, .label = "FPGA FABRIC DTS#5", .unit = "°C", .resolution = 2 },
+	{ .id = 19, .label = "FPGA FABRIC RDTS#1", .unit = "°C", .resolution = 2 },
+	{ .id = 20, .label = "FPGA FABRIC RDTS#2", .unit = "°C", .resolution = 2 },
+	{ .id = 21, .label = "FPGA FABRIC RDTS#3", .unit = "°C", .resolution = 2 },
+	{ .id = 22, .label = "FPGA FABRIC RDTS#4", .unit = "°C", .resolution = 2 },
+	{ .id = 200, .label = "QSFP 3V3 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 201, .label = "VCC 1V8 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 202, .label = "VCCERT FGT 1V0 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 203, .label = "Diode 0C Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 204, .label = "Diode 0A Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 205, .label = "Board 1 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 206, .label = "Diode 03 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 207, .label = "Diode 04 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 208, .label = "Board 2 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 209, .label = "FPGA VR Phase-0 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 210, .label = "FPGA VR Phase-1 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 211, .label = "FPGA VR Phase-2 Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 212, .label = "QSFP 3V3 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 213, .label = "QSFP 3V3 Current", .unit = "mA", .resolution = 1 },
+	{ .id = 214, .label = "VCC 1V8 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 215, .label = "VCCERT FGT 1V0 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 216, .label = "PCIe 3V3 Power Monitor 1 Current", .unit = "mA", .resolution = 1 },
+	{ .id = 217, .label = "PCIe 3V3 Power Monitor 2 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 218, .label = "PCIe 12V Power Monitor 1 Current", .unit = "mA", .resolution = 1 },
+	{ .id = 219, .label = "PCIe 12V Power Monitor 2 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 220, .label = "ATX 12V Power Monitor 1 Current", .unit = "mA", .resolution = 1 },
+	{ .id = 221, .label = "ATX 12V Power Monitor 2 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 222, .label = "FPGA VR Vin Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 223, .label = "FPGA VR VCORE Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 224, .label = "FPGA VR 0V8 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 225, .label = "FPGA VR 1V2 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 226, .label = "FPGA VR VCORE Current", .unit = "mA", .resolution = 1 },
+	{ .id = 227, .label = "FPGA VR 0V8 Current", .unit = "mA", .resolution = 1 },
+	{ .id = 228, .label = "FPGA VR 1V2 Current", .unit = "mA", .resolution = 1 },
+	{ .id = 229, .label = "FPGA VR Controller Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 230, .label = "Board Power", .unit = "mW", .resolution = 1 },
+	{ .id = 32768, .label = "Virt FPGA Temperature", .unit = "°C", .resolution = 2 }
+/*
+	{ .id = 60, .label = "Board Top Near FPGA", .unit = "°C", .resolution = 2 },
+	{ .id = 61, .label = "Board Bottom Near CVL", .unit = "°C", .resolution = 2 },
+	{ .id = 62, .label = "Board Top East Near VRs Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 63, .label = "Columbiaville Die Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 64, .label = "Board Rear Side Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 65, .label = "Board Front Side Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 66, .label = "QSFP1(Primary) Case Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 67, .label = "QSFP2(Secondary) Case Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 68, .label = "FPGA Core Voltage Phase 0 VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 69, .label = "FPGA Core Voltage Phase 1 VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 70, .label = "FPGA Core Voltage Phase 2 VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 71, .label = "FPGA Core Voltage VR Controller Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 72, .label = "FPGA VCCH VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 73, .label = "FPGA VCC_1V2 VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 74, .label = "FPGA VCCH & VCC_1V2 VR Controller Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 75, .label = "3V3 VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 76, .label = "CVL Core Voltage VR Temperature", .unit = "°C", .resolution = 2 },
+	{ .id = 77, .label = "FPGA P-Tile Temperature [Remote]", .unit = "°C", .resolution = 2 },
+	{ .id = 78, .label = "FPGA E-Tile Temperature [Remote]", .unit = "°C", .resolution = 2 },
+	{ .id = 79, .label = "FPGA Core Temperature [Remote]", .unit = "°C", .resolution = 2 },
+	{ .id = 80, .label = "FPGA Corner Temperature [Remote]", .unit = "°C", .resolution = 2 },
+	{ .id = 100, .label = "Inlet 12V PCIe Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 101, .label = "Inlet 12V PCIe Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 102, .label = "Inlet 12V Aux Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 103, .label = "Inlet 12V Aux Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 104, .label = "Inlet 3V3 PCIe Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 105, .label = "Inlet 3V3 PCIe Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 108, .label = "Board Power", .unit = "mW", .resolution = 1 },
+	{ .id = 130, .label = "FPGA Core Voltage Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 131, .label = "FPGA Core Voltage Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 132, .label = "FPGA VCCH Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 133, .label = "FPGA VCCH Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 134, .label = "FPGA VCC_1V2 Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 135, .label = "FPGA VCC_1V2 Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 136, .label = "FPGA VCCH_GXER_1V1 & VCCA_1V8 [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 137, .label = "FPGA VCCH_GXER_1V1 & VCCA_1V8 [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 138, .label = "FPGA VCCIO_1V2 [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 139, .label = "FPGA VCCIO_1V2 [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 140, .label = "CVL Non Core Rails Inlet [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 141, .label = "CVL Non Core Rails Inlet [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 142, .label = "MAX10 & Board CLK PWR 3V3 Inlet [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 143, .label = "MAX10 & Board CLK PWR 3V3 Inlet [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 144, .label = "CVL Core Voltage Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 145, .label = "CVL Core Voltage Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 148, .label = "Board 3V3 VR [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 149, .label = "Board 3V3 VR [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 150, .label = "QSFP 3V3 Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 151, .label = "QSFP 3V3 Rail [Current]", .unit = "mA", .resolution = 1 },
+	{ .id = 152, .label = "QSFP (Primary) Supply Voltage Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 153, .label = "QSFP (Secondary) Supply Voltage Rail [Voltage]", .unit = "mV", .resolution = 1 },
+	{ .id = 180, .label = "VCCCLK_GXER_2V5 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 181, .label = "AVDDH_1V1_CVL Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 182, .label = "VDDH_1V8_CVL Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 183, .label = "VCCA_PLL Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 184, .label = "VCCRT_GXER_0V9 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 185, .label = "VCCRT_GXPL_0V9 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 186, .label = "VCCH_GXPL_1V8 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 187, .label = "VCCPT_1V8 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 188, .label = "VCC_3V3_M10 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 189, .label = "VCC_1V8_M10 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 190, .label = "VCC_1V2_EMIF1_2_3 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 191, .label = "VCC_1V2_EMIF4_5 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 192, .label = "VCCA_1V8 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 193, .label = "VCCH_GXER_1V1 Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 194, .label = "AVDD_ETH_0V9_CVL Voltage", .unit = "mV", .resolution = 1 },
+	{ .id = 195, .label = "AVDD_PCIE_0V9_CVL Voltage", .unit = "mV", .resolution = 1 },
+*/
+};
+
+static struct bel_sensor_info bel_power_regulator_info[] = {
+	[BEL_PWR_REG_IR38062_VOUT]  = { .label = "IR38062 Voltage",      .unit = "mV", .resolution = 1 },
+	[BEL_PWR_REG_IR38062_IOUT]  = { .label = "IR38062 Current",      .unit = "mA", .resolution = 1 },
+	[BEL_PWR_REG_IR38062_VIN]   = { .label = "IR38062 Input",        .unit = "mV", .resolution = 1 },
+	[BEL_PWR_REG_IR38062_TEMP]  = { .label = "IR38062 Temperature",  .unit = "°C", .resolution = 2 },
+	[BEL_PWR_REG_IR38063_VOUT]  = { .label = "IR38063 Voltage",      .unit = "mV", .resolution = 1 },
+	[BEL_PWR_REG_IR38063_IOUT]  = { .label = "IR38063 Current",      .unit = "mA", .resolution = 1 },
+	[BEL_PWR_REG_IR38063_VIN]   = { .label = "IR38063 Input",        .unit = "mV", .resolution = 1 },
+	[BEL_PWR_REG_IR38063_TEMP]  = { .label = "IR38063 Temperature",  .unit = "°C", .resolution = 2 },
+	[BEL_PWR_REG_ISL68220_VOUT] = { .label = "ISL68220 Voltage",     .unit = "mV", .resolution = 1 },
+	[BEL_PWR_REG_ISL68220_IOUT] = { .label = "ISL68220 Current",     .unit = "mA", .resolution = 1 },
+	[BEL_PWR_REG_ISL68220_VIN]  = { .label = "ISL68220 Input",       .unit = "mV", .resolution = 1 },
+	[BEL_PWR_REG_ISL68220_TEMP] = { .label = "ISL68220 Temperature", .unit = "°C", .resolution = 2 }
+};
+
+struct pwron_status {
+	uint64_t value;
+	char str[256];
+};
+
+static struct pwron_status pwron_status_info[] = {
+	{.value = 0, .str = "Default(not attempted)" },
+	{.value = 1, .str = "Under progress" },
+	{.value = 2, .str = "Success"},
+	{.value = 3, .str = "Failed" },
+	{.value = 9, .str = "Repower cycle under progress" },
+	{.value = 0xa, .str = "Repower cycle success" },
+	{.value = 0xb, .str = "Repower cycle failed" }
+};
+
+static void bel_print_bool(const char *label, uint32_t value, size_t offset, const char *one, const char *zero)
+{
+	bool bit = (value >> offset) & 0x1;
+
+	printf("      " BEL_LABEL_FMT "%s\n", 46, label, bit ? one : zero);
+}
+
+static void bel_print_bit(const char *label, uint32_t value, size_t offset)
+{
+	bel_print_bool(label, value, offset, "1", "0");
+}
+
+static void bel_print_pass(const char *label, uint32_t value, size_t offset)
+{
+	bel_print_bool(label, value, offset, "No", "Yes");
+}
+
+static void bel_print_fail(const char *label, uint32_t value, size_t offset)
+{
+	bel_print_bool(label, value, offset, "Yes", "No");
+}
+
+static void bel_print_field(const char *label, uint32_t value, size_t first, size_t last)
+{
+	uint32_t mask = UINT_MAX >> (32 - (last - first));
+	uint32_t field = (value >> first) & mask;
+
+	printf("      " BEL_LABEL_FMT "0x%x\n", 46, label, field);
+}
+
+static void bel_print_pwr_on_sts(const char *label, uint32_t value, size_t first, size_t last)
+{
+	uint32_t mask = UINT_MAX >> (32 - (last - first));
+	uint32_t field = (value >> first) & mask;
+	size_t i = 0;
+	for (i = 0; i < ARRAY_SIZE(pwron_status_info); i++) {
+		if (pwron_status_info[i].value == field) {
+			printf("      " BEL_LABEL_FMT "%s(0x%x)\n", 46, label, pwron_status_info[i].str, field);
+			return;
+		}
+	}
+	printf("      " BEL_LABEL_FMT "(%s)0x%x\n", 46, label, "reserved", field);
+}
+
+static void bel_print_value(const char *label, uint32_t value)
+{
+	printf("    " BEL_LABEL_FMT "0x%08x\n", 48, label, value);
+}
+
+static void bel_print_timeofday(const char *label, struct bel_timeof_day *time_of_day)
+{
+	char time_str[26] = { 0 };
+	time_t time_sec = 0;
+
+	// Timestamps are 64-bit milliseconds:
+	uint64_t correct_time = ((uint64_t)time_of_day->header.timespamp_high << 32) +
+		time_of_day->header.timestamp_low;
+
+	if (time_of_day->header.timespamp_high == 0) {
+		uint64_t offset = ((uint64_t)time_of_day->timeofday_offset_high << 32) +
+			time_of_day->timeofday_offset_low;
+		correct_time += offset;
+	}
+
+	// Convert milliseconds to seconds; no rounding up from 500 milliseconds!
+	time_sec = correct_time / 1000UL;
+
+	if (ctime_r(&time_sec, time_str) == NULL) {
+		OPAE_ERR("Failed to format time: %s", strerror(errno));
+		return;
+	}
+	printf("  " BEL_LABEL_FMT "%s", 50, label, time_str);
+}
+
+static void bel_print_header(const char *label, struct bel_header *header)
+{
+	// Convert milliseconds to seconds;
+	time_t time_sec = (((uint64_t)header->timespamp_high << 32) | header->timestamp_low) / 1000UL;
+	char time_str[26] = { 0 };
+
+	if (ctime_r(&time_sec, time_str) == NULL) {
+		OPAE_ERR("Failed to format time: %s", strerror(errno));
+		return;
+	}
+
+	printf("  " BEL_LABEL_FMT "%s", 50, label, time_str);
+}
+
+static void reserved_field(const char *label, uint32_t value, size_t first, size_t last)
+{
+	uint32_t mask = UINT_MAX >> (32 - (last - first));
+	uint32_t field = (value >> first) & mask;
+	if (label == NULL)
+		label = "Reserved";
+
+	if (field != 0)
+		printf("      " BEL_LABEL_FMT "*** RESERVED FIELD [%lu:%lu] IS NOT ZERO: 0x%X\n", 46, label, last - 1, first, field);
+}
+
+static void reserved_bit(const char *label, uint32_t value, size_t offset)
+{
+	bool bit = (value >> offset) & 0x1;
+	if (label == NULL)
+		label = "Reserved";
+
+	if (bit)
+		printf("      " BEL_LABEL_FMT "*** RESERVED BIT [%lu] IS NOT ZERO: %d\n", 46, label, offset, bit);
+}
+
+void bel_print_power_on_status(struct bel_power_on_status *status, struct bel_timeof_day *timeof_day, bool print_bits)
+{
+	if (status->header.magic != BEL_POWER_ON_STATUS)
+		return;
+
+	if (timeof_day->header.magic != BEL_TIMEOF_DAY_STATUS)
+		return;
+
+	/* Power on status is logged immediately after power on.
+	Time of the day information is written by SW into a BMC register.
+	This write will take some time after power on and hence with Power
+	on log there is no timestamp value available.*/
+	bel_print_timeofday("Power On Status Time", timeof_day);
+
+	/* Register 0x80 */
+	bel_print_value("Status (0x80)",        status->status);
+	reserved_field(NULL,                    status->status,  0, 24);
+	reserved_field(NULL,                    0xFF,  0, 24);
+	reserved_bit(NULL,                      ~0,  22);
+	bel_print_pwr_on_sts("Power On Code FPGA", status->status, 24, 28);
+	bel_print_pwr_on_sts("Power On Code CVL", status->status, 28, 32);
+
+	/* Register 0xa0 */
+	bel_print_value("FPGA_Status (0xA0)",   status->fpga_status);
+	bel_print_field("FPGA Page",            status->fpga_status,  0, 3);
+	bel_print_bit("FPGA Configured Page",   status->fpga_status,  3);
+	bel_print_bit("FPGA Config Timeline",   status->fpga_status,  4);
+	bel_print_bit("Flow Done",              status->fpga_status,  5);
+	reserved_field(NULL,                    status->fpga_status,  6, 12);
+	bel_print_field("FSM State",            status->fpga_status, 12, 16);
+	bel_print_field("Duration",             status->fpga_status, 16, 30);
+	reserved_field(NULL, status->fpga_status, 30, 32);
+
+	/* Register 0xa4 */
+	bel_print_value("FPGA_Config Status (0xA4)",  status->fpga_config_status);
+	bel_print_field("Config Status",              status->fpga_config_status,  0, 4);
+	bel_print_bit("Config FW Seq Fail",           status->fpga_config_status,  4);
+	bel_print_field("nStatus Stuck Low Restarts", status->fpga_config_status,  5, 8);
+	bel_print_field("Image Fail Recycle Count",   status->fpga_config_status,  8, 10);
+	bel_print_field("1st Power On Page number",   status->fpga_config_status, 10, 13);
+	bel_print_field("2nd Power On Page number",   status->fpga_config_status, 13, 16);
+	bel_print_field("3nd Power On Page number",   status->fpga_config_status, 16, 19);
+	reserved_field(NULL,                          status->fpga_config_status, 19, 32);
+
+	/* Register 0x90 */
+	bel_print_value("Sequencer Status 1 (0x90)", status->sequencer_status_1);
+	if (print_bits) {
+		bel_print_bit("IDLE_ST", status->sequencer_status_1, 0);
+		bel_print_bit("PWR_CLS_DEC_FPGA_ST", status->sequencer_status_1, 1);
+		bel_print_bit("PG_3V3_5V_ST", status->sequencer_status_1, 2);
+		bel_print_bit("WAIT_10MS_FPGA_ST", status->sequencer_status_1, 3);
+		bel_print_bit("FPGA_GRP1_EN_ST", status->sequencer_status_1, 4);
+		bel_print_bit("FPGA_GRP2_EN_ST", status->sequencer_status_1, 5);
+		bel_print_bit("FPGA_GRP3_EN_ST", status->sequencer_status_1, 6);
+		bel_print_bit("PG_VTT_0V6_CHK_ST", status->sequencer_status_1, 7);
+		bel_print_bit("FPGA_GRP1_PWR_DWN_ST", status->sequencer_status_1, 8);
+		bel_print_bit("FPGA_GRP2_PWR_DWN_ST", status->sequencer_status_1, 9);
+		bel_print_bit("FPGA_GRP3_PWR_DWN_ST", status->sequencer_status_1, 10);
+		bel_print_bit("FPGA_PWR_ON_ST", status->sequencer_status_1, 11);
+		bel_print_bit("FPGA_PWR_OFF_ST", status->sequencer_status_1, 12);
+		reserved_field(NULL, status->sequencer_status_1, 13, 16);
+		bel_print_bit("PWR_CLS_DEC_CVL_ST", status->sequencer_status_1, 16);
+		bel_print_bit("CVL_VCC_1V1_ST", status->sequencer_status_1, 17);
+		bel_print_bit("CVL_WAIT_100US_ST", status->sequencer_status_1, 18);
+		bel_print_bit("CVL_3V3_1V8_EN_ST", status->sequencer_status_1, 19);
+		bel_print_bit("CVL_VDD_0V8_EN_ST", status->sequencer_status_1, 20);
+		bel_print_bit("CVL_AVDD_ETH_EN_ST", status->sequencer_status_1, 21);
+		bel_print_bit("CVL_AVDD_PCIE_1V1_EN_ST", status->sequencer_status_1, 22);
+		bel_print_bit("CVL_SI5392_CHK_ST", status->sequencer_status_1, 23);
+		bel_print_bit("CVL_LAN_100US_WAIT_ST", status->sequencer_status_1, 24);
+		bel_print_bit("CVL_LAN_PG_ST", status->sequencer_status_1, 25);
+		bel_print_bit("CVL_PWR_ON_ST", status->sequencer_status_1, 26);
+		bel_print_bit("CVL_LAN_PWR_DWN_ST", status->sequencer_status_1, 27);
+		bel_print_bit("CVL_AVDD_PWR_DWN_ST", status->sequencer_status_1, 28);
+		bel_print_bit("CVL_VDD_0V8_PWR_DWN_ST", status->sequencer_status_1, 29);
+		bel_print_bit("CVL_3V3_1V8_PWR_DWN_ST", status->sequencer_status_1, 30);
+		bel_print_bit("CVL_PWR_OFF_ST", status->sequencer_status_1, 31);
+	}
+
+	/* Register 0x94 */
+	bel_print_value("Sequencer Status 2 (0x94)", status->sequencer_status_2);
+	if (print_bits) {
+		bel_print_bit("EN_VCCL_FPGA_VID", status->sequencer_status_2, 0);
+		bel_print_bit("EN_VCCL_SDM_0V8_VCCH_0V9", status->sequencer_status_2, 1);
+		bel_print_bit("EN_FPGA_GRP2", status->sequencer_status_2, 2);
+		bel_print_bit("EN_VPP_2V5", status->sequencer_status_2, 3);
+		bel_print_bit("EN_VCCIO_1V8_SDM_1V8", status->sequencer_status_2, 4);
+		bel_print_bit("EN_VCC_1V2", status->sequencer_status_2, 5);
+		bel_print_bit("EN_3V3_CVL", status->sequencer_status_2, 6);
+		bel_print_bit("EN_1V8_CVL", status->sequencer_status_2, 7);
+		bel_print_bit("EN_VDD_0V8_CVL", status->sequencer_status_2, 8);
+		bel_print_bit("EN_AVDD_ETH_0V9_CVL", status->sequencer_status_2, 9);
+		bel_print_bit("EN_AVDD_PCIE_0V9_CVL", status->sequencer_status_2, 10);
+		bel_print_bit("EN_AVDDH_1V1_CVL", status->sequencer_status_2, 11);
+		bel_print_bit("EN_PWR_QSFP0", status->sequencer_status_2, 12);
+		bel_print_bit("EN_PWR_QSFP1", status->sequencer_status_2, 13);
+		bel_print_bit("FLT_CFP_ISL", status->sequencer_status_2, 14);
+		reserved_bit(NULL, status->sequencer_status_2, 15);
+		bel_print_bit("SI5392_LOL", status->sequencer_status_2, 16);
+		bel_print_bit("POWER_GOOD", status->sequencer_status_2, 17);
+		bel_print_bit("LAN_PWR_GOOD", status->sequencer_status_2, 18);
+		bel_print_bit("PM_ALERTN_3V3", status->sequencer_status_2, 19);
+		bel_print_bit("FPGA_VID_ALERTN", status->sequencer_status_2, 20);
+		bel_print_bit("VR_VID_ALERTN", status->sequencer_status_2, 21);
+		bel_print_bit("FPGA_THERM_ALERTN", status->sequencer_status_2, 22);
+		bel_print_bit("CVL_THERM_ALERTN", status->sequencer_status_2, 23);
+		bel_print_bit("EDGE_PWR_WARN", status->sequencer_status_2, 24);
+	}
+	/* Register 0x98 */
+	bel_print_value("Power Good Status (0x98)", status->power_good_status);
+	if (print_bits) {
+		bel_print_bit("pg_12v_aux_efuse", status->power_good_status, 0);
+		bel_print_bit("pg_12v_pcie_efuse", status->power_good_status, 1);
+		bel_print_bit("pg_vcc_5v", status->power_good_status, 2);
+		bel_print_bit("pg_vcc_3v3", status->power_good_status, 3);
+		bel_print_bit("pg_vccl_fpga_vid", status->power_good_status, 4);
+		bel_print_bit("pg_vccl_sdm_0v8", status->power_good_status, 5);
+		bel_print_bit("pg_vcch_0v9", status->power_good_status, 6);
+		bel_print_bit("pg_vcch_gxer_1v1", status->power_good_status, 7);
+		bel_print_bit("pg_vcca_1v8", status->power_good_status, 8);
+		bel_print_bit("pg_vccclk_gxer_2v5", status->power_good_status, 9);
+		bel_print_bit("pg_vpp_2v5", status->power_good_status, 10);
+		bel_print_bit("pg_vccio_1v8", status->power_good_status, 11);
+		bel_print_bit("pg_sdm_1v8", status->power_good_status, 12);
+		bel_print_bit("pg_vcc_1v2", status->power_good_status, 13);
+		bel_print_bit("pg_vtt_0v6", status->power_good_status, 14);
+		bel_print_bit("pg_vcc_1v1_cvl", status->power_good_status, 15);
+		bel_print_bit("pg_3v3_1v8_cvl", status->power_good_status, 16);
+		bel_print_bit("pg_vdd_0v8_cvl", status->power_good_status, 17);
+		bel_print_bit("pg_avdd_eth_0v9_cvl", status->power_good_status, 18);
+		bel_print_bit("pg_avdd_pcie_0v9_cvl", status->power_good_status, 19);
+		bel_print_bit("pg_avddh_1v1_cvl", status->power_good_status, 20);
+		bel_print_bit("pg_pwr_qsfp0n", status->power_good_status, 21);
+		bel_print_bit("pg_pwr_qsfp1n", status->power_good_status, 22);
+		bel_print_bit("FPGA_THERM_SHDN", status->power_good_status, 23);
+		bel_print_bit("EDGE_PWR_SHDN", status->power_good_status, 24);
+		bel_print_bit("FPGA_NCATTRIP", status->power_good_status, 25);
+		bel_print_bit("VCC_12V_AUX_UV", status->power_good_status, 26);
+		bel_print_bit("VCC_12V_PCIE_UV", status->power_good_status, 27);
+		bel_print_bit("VCC_3V3_PCIE_UV", status->power_good_status, 28);
+		bel_print_bit("VCC_12V_3V3_IN_OV", status->power_good_status, 29);
+		bel_print_bit("QSFPA_MODPRES", status->power_good_status, 30);
+		bel_print_bit("QSFPB_MODPRES", status->power_good_status, 31);
+	}
+}
+
+static void bel_print_sensor_alert(uint32_t sensor_alert, size_t offset)
+{
+	struct bel_sensor_info *info = &bel_sensor_info[offset];
+	size_t last = sizeof(sensor_alert) * 8;
+	size_t i;
+
+	if (offset + last > ARRAY_SIZE(bel_sensor_info))
+		last = ARRAY_SIZE(bel_sensor_info) - offset;
+
+	for (i = 0; i < last; i++, info++)
+		bel_print_fail(info->label, sensor_alert, i);
+}
+void bel_print_power_off_status(struct bel_power_off_status *status, bool print_bits)
+{
+	if (status->header.magic != BEL_POWER_OFF_STATUS)
+		return;
+
+	bel_print_header("Power Off Status Time", &status->header);
+
+	/* Register 0xa0 */
+	bel_print_value("FPGA_Status (0xA0)", status->fpga_status);
+	bel_print_field("FPGA Page", status->fpga_status, 0, 3);
+	bel_print_bit("FPGA Configured Page", status->fpga_status, 3);
+	bel_print_bit("FPGA Config Timeline", status->fpga_status, 4);
+	bel_print_bit("Flow Done", status->fpga_status, 5);
+	reserved_field(NULL, status->fpga_status, 6, 12);
+	bel_print_field("FSM State", status->fpga_status, 12, 16);
+	bel_print_field("Duration", status->fpga_status, 16, 30);
+	reserved_field(NULL, status->fpga_status, 30, 32);
+
+	/* Register 0xa4 */
+	bel_print_value("FPGA_Config Status (0xA4)", status->fpga_config_status);
+	bel_print_field("Config Status", status->fpga_config_status, 0, 4);
+	bel_print_bit("Config FW Seq Fail", status->fpga_config_status, 4);
+	bel_print_field("nStatus Stuck Low Restarts", status->fpga_config_status, 5, 8);
+	bel_print_field("Image Fail Recycle Count", status->fpga_config_status, 8, 10);
+	bel_print_field("1st Power On Page number", status->fpga_config_status, 10, 13);
+	bel_print_field("2nd Power On Page number", status->fpga_config_status, 13, 16);
+	bel_print_field("3nd Power On Page number", status->fpga_config_status, 16, 19);
+	reserved_field(NULL, status->fpga_config_status, 19, 32);
+
+	/* Register 0x84 */
+	bel_print_value("Power Good Record 1 (0x84)", status->record_1);
+	if (print_bits) {
+		bel_print_bit("pg_12v_aux_efuse",     status->record_1,  0);
+		bel_print_bit("pg_12v_pcie_efuse",    status->record_1,  1);
+		bel_print_bit("pg_vcc_5v",            status->record_1,  2);
+		bel_print_bit("pg_vcc_3v3",           status->record_1,  3);
+		bel_print_bit("pg_vccl_fpga_vid",     status->record_1,  4);
+		bel_print_bit("pg_vccl_sdm_0v8",      status->record_1,  5);
+		bel_print_bit("pg_vcch_0v9",          status->record_1,  6);
+		bel_print_bit("pg_vcch_gxer_1v1",     status->record_1,  7);
+		bel_print_bit("pg_vcca_1v8",          status->record_1,  8);
+		bel_print_bit("pg_vccclk_gxer_2v5",   status->record_1,  9);
+		bel_print_bit("pg_vpp_2v5",           status->record_1, 10);
+		bel_print_bit("pg_vccio_1v8",         status->record_1, 11);
+		bel_print_bit("pg_sdm_1v8",           status->record_1, 12);
+		bel_print_bit("pg_vcc_1v2",           status->record_1, 13);
+		bel_print_bit("pg_vtt_0v6",           status->record_1, 14);
+		bel_print_bit("pg_vcc_1v1_cvl",       status->record_1, 15);
+		bel_print_bit("pg_3v3_1v8_cvl",       status->record_1, 16);
+		bel_print_bit("pg_vdd_0v8_cvl",       status->record_1, 17);
+		bel_print_bit("pg_avdd_eth_0v9_cvl",  status->record_1, 18);
+		bel_print_bit("pg_avdd_pcie_0v9_cvl", status->record_1, 19);
+		bel_print_bit("pg_avddh_1v1_cvl",     status->record_1, 20);
+		bel_print_bit("vcc_12v_aux_uv",       status->record_1, 21);
+		bel_print_bit("vcc_3v3_pcie_uv",      status->record_1, 22);
+		bel_print_bit("vcc_3v3_pcie_uv",      status->record_1, 23);
+		bel_print_bit("vcc_12v_3v3_in_ov",    status->record_1, 24);
+		bel_print_bit("fpga_therm_shdn",      status->record_1, 25);
+		bel_print_bit("edge_pwr_shdn",        status->record_1, 26);
+		bel_print_bit("fpga_ncattrip",        status->record_1, 27);
+		bel_print_bit("si5392_lol",           status->record_1, 28);
+		reserved_bit(NULL,                    status->record_1, 29);
+		reserved_bit(NULL,                    status->record_1, 30);
+		bel_print_bit("user request",         status->record_1, 31);
+	}
+
+	/* Register 0x88 */
+	bel_print_value("Power Good Record 2 (0x88)", status->record_2);
+	if (print_bits) {
+		bel_print_bit("PM_ALERTN_3V3",      status->record_2,  0);
+		bel_print_bit("FPGA_VID_ALERTN",    status->record_2,  1);
+		bel_print_bit("VR_VID_ALERTN",      status->record_2,  2);
+		bel_print_bit("FPGA_THERM_ALERTN",  status->record_2,  3);
+		bel_print_bit("EDGE_PWR_WARN",      status->record_2,  4);
+		reserved_field(NULL,                status->record_2,  5, 32);
+	}
+
+	/* Register 0x50 */
+	bel_print_value("GPI Status (0x50)", status->general_purpose_input_status);
+	if (print_bits) {
+		bel_print_bit("Board revision strap LSB, hard strap",       status->general_purpose_input_status,  0);
+		bel_print_bit("Board revision strap",                       status->general_purpose_input_status,  1);
+		bel_print_bit("Power class 0 strap",                        status->general_purpose_input_status,  2);
+		bel_print_bit("Power class 1 strap",                        status->general_purpose_input_status,  3);
+		bel_print_bit("SM bus I2C address bit setting, hard strap", status->general_purpose_input_status,  4);
+		bel_print_bit("CVL present indication, hard strap",         status->general_purpose_input_status,  5);
+		bel_print_bit("Alert indication from PM bus VRs",           status->general_purpose_input_status,  6);
+		bel_print_bit("FM61 SDM VID alertn output",                 status->general_purpose_input_status,  7);
+		bel_print_bit("Output from ED8401",                         status->general_purpose_input_status,  8);
+		bel_print_bit("Warning alert output from TMP464",           status->general_purpose_input_status,  9);
+		bel_print_bit("Output from INA3221",                        status->general_purpose_input_status, 10);
+		bel_print_bit("Loss of input reference to SI53254",         status->general_purpose_input_status, 11);
+		bel_print_bit("Loss of lLock indication from Zarlink",      status->general_purpose_input_status, 12);
+		bel_print_bit("Loss of Lock Indication from Si5392",        status->general_purpose_input_status, 13);
+		reserved_bit(NULL,                                          status->general_purpose_input_status, 14);
+		bel_print_bit("Interrupt from IO Expander",                 status->general_purpose_input_status, 15);
+		bel_print_bit("Output from INA3221",                        status->general_purpose_input_status, 16);
+		bel_print_bit("QSFP-A module presence",                     status->general_purpose_input_status, 17);
+		bel_print_bit("QSFP-B module presence",                     status->general_purpose_input_status, 18);
+		reserved_field(NULL,                                        status->general_purpose_input_status, 19, 32);
+	}
+
+	/* Register 0x410 */
+	bel_print_value("Sensor Failed (0x410)", status->sensor_failed);
+	if (print_bits) {
+		bel_print_pass("qsfp dc-dc mpm3695",    status->sensor_failed,  0);
+		bel_print_pass("fs1412_dev1",               status->sensor_failed,  1);
+		bel_print_pass("fs1412_dev2",               status->sensor_failed,  2);
+		bel_print_pass("ads7142_dev1",              status->sensor_failed,  3);
+		bel_print_pass("ads7142_dev2",              status->sensor_failed,  4);
+		bel_print_pass("ads7142_dev3",              status->sensor_failed,  5);
+		bel_print_pass("fpga_remote_temp mcp9903_dev1",              status->sensor_failed,  6);
+		bel_print_pass("fpga_remote_temp mcp9903_dev2",              status->sensor_failed,  7);
+		bel_print_pass("fpga_core_vol_pwr_temp mp2926",                    status->sensor_failed,  8);
+		bel_print_pass("fpga_fab_tile_temp",        status->sensor_failed,  9);
+
+		//bel_print_pass("fpga_remote_temp",        status->sensor_failed,  0);
+		//bel_print_pass("board_temp",              status->sensor_failed,  1);
+		//bel_print_pass("inlet_12v_pcie",          status->sensor_failed,  2);
+		//bel_print_pass("fpga_vcch_gxer",          status->sensor_failed,  3);
+		//bel_print_pass("max10_board_clk_pwr",     status->sensor_failed,  4);
+		//bel_print_pass("cvl_core_vol_temp",       status->sensor_failed,  5);
+		//bel_print_pass("board_3v3_vol_temp",      status->sensor_failed,  6);
+		//bel_print_pass("fpga_vcch",               status->sensor_failed,  7);
+		//bel_print_pass("fpga_core_vol_pwr_temp",  status->sensor_failed,  8);
+		//bel_print_pass("fpga_fab_tile_temp",      status->sensor_failed,  9);
+		bel_print_pass("qsfp1_sts",               status->sensor_failed, 10);
+		//bel_print_pass("qsfp2_sts",               status->sensor_failed, 11);
+		//bel_print_pass("io_expander_sts",         status->sensor_failed, 12);
+		bel_print_pass("qsfp1_controller_access", status->sensor_failed, 13);
+		bel_print_pass("qsfp1_module_plugged",    status->sensor_failed, 14);
+		bel_print_pass("qsfp1_module_supported",  status->sensor_failed, 15);
+		bel_print_pass("qsfp1_diag_data_avl",     status->sensor_failed, 16);
+		//bel_print_pass("qsfp2_controller_access", status->sensor_failed, 17);
+		//bel_print_pass("qsfp2_module_plugged",    status->sensor_failed, 18);
+		//bel_print_pass("qsfp2_module_supported",  status->sensor_failed, 19);
+		//bel_print_pass("qsfp2_diag_data_avl",     status->sensor_failed, 20);
+		reserved_field(NULL,                      status->sensor_failed, 21, 31);
+		bel_print_pass("overall_devices",         status->sensor_failed, 31);
+	}
+
+	/* Register 0x414 */
+	bel_print_value("Sensor Alert 1 (0x414)", status->sensor_alert_1);
+
+	if (print_bits)
+		bel_print_sensor_alert(status->sensor_alert_1, 0);
+
+	/* Register 0x418 */
+	bel_print_value("Sensor Alert 2 (0x418)", status->sensor_alert_2);
+
+	if (print_bits)
+		bel_print_sensor_alert(status->sensor_alert_1, 32);
+
+	/* Register 0x41c */
+	bel_print_value("Sensor Alert 3 (0x41C)", status->sensor_alert_3);
+
+	if (print_bits)
+		bel_print_sensor_alert(status->sensor_alert_1, 64);
+}
+
+size_t bel_print_sensor(struct bel_sensor_state *state, size_t last)
+{
+	struct bel_sensor_info *info = NULL;
+	size_t next = last + 1;
+
+	/* Search the info array starting from one past the previous printed sensor */
+	while (next != last) {
+		info = &bel_sensor_info[next];
+
+		if (info->id == state->id)
+			break;
+
+		if (state->id == 0)
+			break;
+
+		next = (next + 1) % ARRAY_SIZE(bel_sensor_info);
+	}
+
+	/* Print nothing if sensor wasn't found */
+	if (next == last)
+		return last;
+
+	if (info->id == 0)
+		return last;
+	printf("    " BEL_LABEL_FMT, 48, info->label);
+	if (state->reading != INT_MAX)
+		printf("%6u %s\n", state->reading / info->resolution, info->unit);
+	else
+		printf("%9s\n", "N/A");
+
+	return next;
+}
+
+void bel_print_sensors_state(struct bel_sensors_state *state)
+{
+	size_t idx = -1;
+	size_t i;
+
+	if (state->header.magic != BEL_SENSORS_STATE)
+		return;
+
+	bel_print_header("Sensor State Time", &state->header);
+
+	for (i = 0; i < ARRAY_SIZE(state->sensor_state); i++)
+		idx = bel_print_sensor(&state->sensor_state[i], idx);
+}
+
+void bel_print_sensors_status_ext(const char *label, struct bel_ext_status *status, size_t idx)
+{
+	struct bel_sensor_info *info = &bel_power_regulator_info[idx];
+	char l[32];
+	size_t i;
+
+	snprintf(l, sizeof(l), "%s Status Word", label);
+	bel_print_value(l, status->word);
+	bel_print_bit("None/Unkown", status->word, 0);
+	bel_print_bit("CML", status->word, 1);
+	bel_print_bit("Temperature", status->word, 2);
+	bel_print_bit("Vin Undervoltage", status->word, 3);
+	bel_print_bit("Iout Overcurrent", status->word, 4);
+	bel_print_bit("Vout Overvoltage", status->word, 5);
+	bel_print_bit("Off", status->word, 6);
+	bel_print_bit("Busy", status->word, 7);
+	bel_print_bit("None/Unknown", status->word, 8);
+	bel_print_bit("Other", status->word, 9);
+	bel_print_bit("Fans", status->word, 10);
+	bel_print_bit("Power Good", status->word, 11);
+	bel_print_bit("Manufacturer Specific Fault", status->word, 12);
+	bel_print_bit("Input", status->word, 13);
+	bel_print_bit("Iout/Pout", status->word, 14);
+	bel_print_bit("Vout", status->word, 15);
+
+	for (i = 0; i < 4; i++) {
+		printf("    " BEL_LABEL_FMT "%7u %s\n", 48, info->label, status->data[i + 1], info->unit);
+		info++;
+	}
+
+	snprintf(l, sizeof(l), "%s Status CML", label);
+	bel_print_value(l, status->cml);
+	bel_print_bit("Other Fault", status->cml, 0);
+	bel_print_bit("Communication Fault", status->cml, 1);
+	bel_print_bit("Processor Fault", status->cml, 3);
+	bel_print_bit("Memory Fault", status->cml, 4);
+	bel_print_bit("Packet Error Check Fault", status->cml, 5);
+	bel_print_bit("Invalid/Unsupported Data", status->cml, 6);
+	bel_print_bit("Invalid/Unsupported Command", status->cml, 7);
+}
+
+void bel_print_sensors_status(struct bel_sensors_status *status)
+{
+	if (status->header.magic != BEL_SENSORS_STATUS)
+		return;
+
+	bel_print_header("Sensor Status Time", &status->header);
+
+	bel_print_value("INA3221 1 Mask Enable", status->ina3221_1_mask_enable);
+	bel_print_value("INA3221 2 Mask Enable", status->ina3221_2_mask_enable);
+	bel_print_value("INA3221 3 Mask Enable", status->ina3221_3_mask_enable);
+	bel_print_sensors_status_ext("IR38062", &status->ir38062, BEL_PWR_REG_IR38062_VOUT);
+	bel_print_sensors_status_ext("IR38063", &status->ir38063, BEL_PWR_REG_IR38063_VOUT);
+	bel_print_sensors_status_ext("ISL68220", &status->isl68220, BEL_PWR_REG_ISL68220_VOUT);
+	bel_print_value("ED8401 Status", status->ed8401_status);
+}
+
+void bel_print_max10_seu(struct bel_max10_seu *status)
+{
+	if (status->header.magic != BEL_MAX10_SEU_STATUS)
+		return;
+	bel_print_header("Max10 SEU Time", &status->header);
+	bel_print_bit("MAX10 SEU error status", status->max10_seu, 0);
+
+}
+
+void bel_print_timeof_day(struct bel_timeof_day *timeof_day)
+{
+	if (timeof_day->header.magic != BEL_TIMEOF_DAY_STATUS)
+		return;
+
+	bel_print_header("Time of day", &timeof_day->header);
+	bel_print_timeofday("Time of day offset", timeof_day);
+
+	bel_print_value("TimeOfDay offset low", timeof_day->timeofday_offset_low);
+	bel_print_value("TimeOfDay offset high", timeof_day->timeofday_offset_high);
+}
+
+void bel_print_fpga_seu(struct bel_fpga_seu *status)
+{
+	if (status->header.magic != BEL_FPGA_SEU_STATUS)
+		return;
+
+	bel_print_header("FPGA SEU Time", &status->header);
+	bel_print_bit("FPGA SEU error status", status->fpga_seu, 1);
+}
+
+void bel_print_pci_error_status(struct bel_pci_error_status *status, bool print_bits)
+{
+	if (status->header.magic != BEL_PCI_ERROR_STATUS)
+		return;
+
+	bel_print_header("PCI Error Status Time", &status->header);
+
+	// PCIe Link Status
+	bel_print_value("PCIe Link Status", status->pcie_link_status);
+	if (print_bits) {
+		bel_print_field("Current Link Speed", status->pcie_link_status, 0, 3);
+		bel_print_field("Negotiated Link Speed", status->pcie_link_status, 4, 9);
+		bel_print_bit("Link Training ", status->pcie_link_status, 11);
+		bel_print_bit("Slot Clock Configuration", status->pcie_link_status, 12);
+		bel_print_bit("Data link layer link active", status->pcie_link_status, 13);
+		bel_print_bit("Link Bandwidth Management Status", status->pcie_link_status, 14);
+		bel_print_bit("Link Autonomous Management Status", status->pcie_link_status, 15);
+	}
+
+	// PCIe Uncorrectable Error
+	bel_print_value("PCIe Uncorrectable Error", status->pcie_uncorr_err);
+	if (print_bits) {
+		bel_print_bit("Data Link Protocol error Status", status->pcie_uncorr_err, 4);
+		bel_print_bit("Surprise down error Status", status->pcie_uncorr_err, 5);
+		bel_print_bit("Poisoned TLP received", status->pcie_uncorr_err, 12);
+		bel_print_bit("Flow Control Protocol Errors Status", status->pcie_uncorr_err, 13);
+		bel_print_bit("Completion Timeout Status", status->pcie_uncorr_err, 14);
+		bel_print_bit("Completer Abort error Status", status->pcie_uncorr_err, 15);
+		bel_print_bit("Unexpected Completion Status", status->pcie_uncorr_err, 16);
+		bel_print_bit("Receiver Overflow Status", status->pcie_uncorr_err, 17);
+		bel_print_bit("Malformed TLP Status", status->pcie_uncorr_err, 18);
+		bel_print_bit("ECRC Error Status", status->pcie_uncorr_err, 19);
+		bel_print_bit("Unsupported Request Error Status", status->pcie_uncorr_err, 20);
+		bel_print_bit("ACS Violation Status", status->pcie_uncorr_err, 21);
+		bel_print_bit("Uncorrectable Internal Error Status", status->pcie_uncorr_err, 22);
+		bel_print_bit("MC Blocked TLP Status", status->pcie_uncorr_err, 23);
+		bel_print_bit("AtomicOp Egress Blocked Status", status->pcie_uncorr_err, 24);
+		bel_print_bit("TLP Prefix Blocked Status", status->pcie_uncorr_err, 25);
+		bel_print_bit("Poisoned TLP Egress Blocked Status", status->pcie_uncorr_err, 26);
+	}
+
+}
+
+void bel_print_pci_v1_error_status(struct bel_pcie_v1_error_status *status, bool print_bits)
+{
+
+	if (status->header.magic != BEL_PCI_V1_ERROR_STATUS)
+		return;
+
+	bel_print_header("PCI Error Status Time", &status->header);
+
+	// PCIe Link Status
+	bel_print_value("PCIe Link Status", status->pcie_link_status);
+	if (print_bits) {
+		bel_print_field("Current Link Speed", status->pcie_link_status, 0, 3);
+		bel_print_field("Negotiated Link Speed", status->pcie_link_status, 4, 9);
+		bel_print_bit("Link Training ", status->pcie_link_status, 11);
+		bel_print_bit("Slot Clock Configuration", status->pcie_link_status, 12);
+		bel_print_bit("Data link layer link active", status->pcie_link_status, 13);
+		bel_print_bit("Link Bandwidth Management Status", status->pcie_link_status, 14);
+		bel_print_bit("Link Autonomous Management Status", status->pcie_link_status, 15);
+	}
+
+	// PCIe Uncorrectable Error
+	bel_print_value("PCIe Uncorrectable Error", status->pcie_uncorr_err);
+	if (print_bits) {
+		bel_print_bit("Data Link Protocol error Status", status->pcie_uncorr_err, 4);
+		bel_print_bit("Surprise down error Status", status->pcie_uncorr_err, 5);
+		bel_print_bit("Poisoned TLP received", status->pcie_uncorr_err, 12);
+		bel_print_bit("Flow Control Protocol Errors Status", status->pcie_uncorr_err, 13);
+		bel_print_bit("Completion Timeout Status", status->pcie_uncorr_err, 14);
+		bel_print_bit("Completer Abort error Status", status->pcie_uncorr_err, 15);
+		bel_print_bit("Unexpected Completion Status", status->pcie_uncorr_err, 16);
+		bel_print_bit("Receiver Overflow Status", status->pcie_uncorr_err, 17);
+		bel_print_bit("Malformed TLP Status", status->pcie_uncorr_err, 18);
+		bel_print_bit("ECRC Error Status", status->pcie_uncorr_err, 19);
+		bel_print_bit("Unsupported Request Error Status", status->pcie_uncorr_err, 20);
+		bel_print_bit("ACS Violation Status", status->pcie_uncorr_err, 21);
+		bel_print_bit("Uncorrectable Internal Error Status", status->pcie_uncorr_err, 22);
+		bel_print_bit("MC Blocked TLP Status", status->pcie_uncorr_err, 23);
+		bel_print_bit("AtomicOp Egress Blocked Status", status->pcie_uncorr_err, 24);
+		bel_print_bit("TLP Prefix Blocked Status", status->pcie_uncorr_err, 25);
+		bel_print_bit("Poisoned TLP Egress Blocked Status", status->pcie_uncorr_err, 26);
+	}
+
+	// PCIe Uncorrectable Err Mask
+	bel_print_value("PCIe Uncorrectable Err Mask", status->pcie_uncorr_err_mask);
+	if (print_bits) {
+		bel_print_bit("Data Link Protocol error", status->pcie_uncorr_err, 4);
+		bel_print_bit("Surprise down error", status->pcie_uncorr_err, 5);
+		bel_print_bit("Poisoned TLP received", status->pcie_uncorr_err, 12);
+		bel_print_bit("Flow Control Protocol Errors", status->pcie_uncorr_err, 13);
+		bel_print_bit("Completion Timeout", status->pcie_uncorr_err, 14);
+		bel_print_bit("Completer Abort error", status->pcie_uncorr_err, 15);
+		bel_print_bit("Unexpected Completion", status->pcie_uncorr_err, 16);
+		bel_print_bit("Receiver Overflow", status->pcie_uncorr_err, 17);
+		bel_print_bit("Malformed TLP", status->pcie_uncorr_err, 18);
+		bel_print_bit("ECRC Error", status->pcie_uncorr_err, 19);
+		bel_print_bit("Unsupported Request Error", status->pcie_uncorr_err, 20);
+		bel_print_bit("ACS Violation", status->pcie_uncorr_err, 21);
+		bel_print_bit("Uncorrectable Internal Error", status->pcie_uncorr_err, 22);
+		bel_print_bit("MC Blocked TLP", status->pcie_uncorr_err, 23);
+		bel_print_bit("AtomicOp Egress Blocked", status->pcie_uncorr_err, 24);
+		bel_print_bit("TLP Prefix Blocked", status->pcie_uncorr_err, 25);
+		bel_print_bit("Poisoned TLP Egress Blocked", status->pcie_uncorr_err, 26);
+	}
+
+	//PCIE Uncorrectable Err Severity
+	bel_print_value("PCIe Uncorrectable Err Severity", status->pcie_uncorr_err_severity);
+	if (print_bits) {
+		bel_print_bit("Data Link Protocol error", status->pcie_uncorr_err_severity, 4);
+		bel_print_bit("Surprise Down Error", status->pcie_uncorr_err_severity, 5);
+		bel_print_bit("Poisoned TLP", status->pcie_uncorr_err_severity, 12);
+		bel_print_bit("Flow Control protocol error", status->pcie_uncorr_err_severity, 13);
+		bel_print_bit("Completion Timeout", status->pcie_uncorr_err_severity, 14);
+		bel_print_bit("Completer Abort (CA) was transmitted", status->pcie_uncorr_err_severity, 15);
+		bel_print_bit("Unexpected Completion was received", status->pcie_uncorr_err_severity, 16);
+		bel_print_bit("Receiver Overflow", status->pcie_uncorr_err_severity, 17);
+		bel_print_bit("Malformed TLP Received", status->pcie_uncorr_err_severity, 18);
+		bel_print_bit("ECRC Error Detected", status->pcie_uncorr_err_severity, 19);
+		bel_print_bit("Unsupported Request Received", status->pcie_uncorr_err_severity, 20);
+	}
+
+	//PCIE Correctable Err Status
+	bel_print_value("PCIe Correctable Err Status", status->pcie_corr_err_status);
+	if (print_bits) {
+		bel_print_bit("Receiver Error status", status->pcie_corr_err_status, 0);
+		bel_print_bit("Bad TLP status", status->pcie_corr_err_status, 6);
+		bel_print_bit("Bad DLLP status", status->pcie_corr_err_status, 7);
+		bel_print_bit("Replay Number Rollover status", status->pcie_corr_err_status, 8);
+		bel_print_bit("Replay timer Timeout status", status->pcie_corr_err_status, 12);
+		bel_print_bit("Advisory Non-Fatal Error status", status->pcie_corr_err_status, 13);
+		bel_print_bit("Corrected internal error status", status->pcie_corr_err_status, 14);
+	}
+
+	//PCIE Correctable Err Mask
+	bel_print_value("PCIe Correctable Err Mask", status->pcie_corr_err_mask);
+	if (print_bits) {
+		bel_print_bit("Receiver Error", status->pcie_corr_err_status, 0);
+		bel_print_bit("Bad TLP", status->pcie_corr_err_status, 6);
+		bel_print_bit("Bad DLLP", status->pcie_corr_err_status, 7);
+		bel_print_bit("Replay Number Rollover", status->pcie_corr_err_status, 8);
+		bel_print_bit("Replay timer Timeout", status->pcie_corr_err_status, 12);
+		bel_print_bit("Advisory Non-Fatal Error", status->pcie_corr_err_status, 13);
+		bel_print_bit("Corrected internal error", status->pcie_corr_err_status, 14);
+	}
+
+	//PCIE Cap And Ctrl
+	bel_print_value("PCIe Cap And Ctrl", status->pcie_cap_ctrl);
+
+	//PCIE Header Log DW 1
+	bel_print_value("PCIE Header Log DW1", status->pcie_header_log1);
+	//PCIE Header Log DW 2
+	bel_print_value("PCIE Header Log DW2", status->pcie_header_log1);
+	//PCIE Header Log DW 3
+	bel_print_value("PCIE Header Log DW3", status->pcie_header_log1);
+	//PCIE Header Log DW 4
+	bel_print_value("PCIE Header Log DW4", status->pcie_header_log1);
+
+}
+
+uint32_t bel_ptr_count(void)
+{
+	return BEL_BLOCK_COUNT;
+}
+
+uint32_t bel_ptr_next(uint32_t ptr)
+{
+	if (ptr == 0)
+		return BEL_BLOCK_COUNT - 1;
+	else
+		return ptr - 1;
+}
+
+fpga_result bel_ptr(fpga_object fpga_object, uint32_t *ptr)
+{
+	fpga_result res;
+	uint32_t data;
+
+	res = fpgaObjectRead(fpga_object, (uint8_t *)&data, BEL_PTR_OFFSET,
+				sizeof(data), FPGA_OBJECT_RAW);
+
+	if (res != FPGA_OK)
+		return res;
+
+	if (data == UINT_MAX)
+		data = 0;
+
+	if (ptr)
+		*ptr = le32toh(data);
+
+	return res;
+}
+
+fpga_result bel_read(fpga_object fpga_object, uint32_t ptr, struct bel_event *event)
+{
+	size_t offset = ptr * BEL_BLOCK_SIZE;
+	size_t count = sizeof(*event) / sizeof(uint32_t);
+	fpga_result res;
+
+	if (ptr >= BEL_BLOCK_COUNT)
+		return FPGA_INVALID_PARAM;
+
+	res = fpgaObjectRead(fpga_object, (uint8_t *)event, offset, sizeof(*event), FPGA_OBJECT_RAW);
+	if (res != FPGA_OK)
+		return res;
+
+	while (--count)
+		event->data[count] = le32toh(event->data[count]);
+
+	return res;
+}
+
+void bel_print(struct bel_event *event, bool print_sensors, bool print_bits)
+{
+	bel_print_power_on_status(&event->power_on_status, &event->timeof_day, print_bits);
+	bel_print_timeof_day(&event->timeof_day);
+	bel_print_max10_seu(&event->max10_seu);
+	bel_print_fpga_seu(&event->fpga_seu);
+	bel_print_pci_error_status(&event->pci_error_status, print_bits);
+
+	bel_print_power_off_status(&event->power_off_status, print_bits);
+
+	if (print_sensors) {
+		bel_print_sensors_state(&event->sensors_state);
+		bel_print_sensors_status(&event->sensors_status);
+	}
+	bel_print_pci_v1_error_status(&event->pcie_v1_error_status, print_bits);
+
+}
+
+void bel_timespan(struct bel_event *event, uint32_t idx)
+{
+	struct bel_header *header_off = &event->power_off_status.header;
+	time_t off_sec = (((uint64_t)header_off->timespamp_high << 32) |
+		header_off->timestamp_low) /1000UL;
+	char off_str[26] = { 'N', '/', 'A', '\0' };
+	char on_str[26] = { '\0' };
+	time_t on_sec = 0;
+
+	/* Power on status is logged immediately after power on.
+	Time of the day information is written by SW into a BMC register.
+	This write will take some time after power on and hence with Power
+	on log there is no timestamp value available.*/
+	if (event->timeof_day.header.magic != BEL_TIMEOF_DAY_STATUS)
+		return;
+
+	// Timestamps are 64-bit milliseconds:
+	uint64_t correct_time = ((uint64_t)event->timeof_day.header.timespamp_high << 32) +
+		event->timeof_day.header.timestamp_low;
+
+	if (event->timeof_day.header.timespamp_high == 0) {
+		uint64_t offset = ((uint64_t)event->timeof_day.timeofday_offset_high << 32) +
+			event->timeof_day.timeofday_offset_low;
+		correct_time += offset;
+	}
+
+	// Convert milliseconds to seconds; no rounding up from 500 milliseconds!
+	on_sec = correct_time / 1000UL;
+
+	if (ctime_r(&on_sec, on_str) == NULL) {
+		OPAE_ERR("Failed to format time: %s", strerror(errno));
+		return;
+	}
+
+	on_str[24] = '\0';
+
+	if (header_off->magic == BEL_POWER_OFF_STATUS) {
+		if (ctime_r(&off_sec, off_str) == NULL) {
+			OPAE_ERR("Failed to format time: %s", strerror(errno));
+			return;
+		}
+
+		off_str[24] = '\0';
+	}
+
+	if (idx == 0) {
+		printf("%-15s : %-25s : %-25s\n", "Boot Index", "Power-ON Timestamp", "Power-OFF Timestamp");
+		printf("-------------------------------------------------------------------------\n");
+		printf("%-15s - %-20s  - %-20s\n", "Current Boot", on_str, off_str);
+	} else {
+		printf("Boot %-10u - %-20s  - %-20s\n", idx, on_str, off_str);
+	}
+
+}
+
+bool bel_empty(struct bel_event *event)
+{
+	return event->power_on_status.header.magic == UINT_MAX;
+}
diff --git a/libraries/libboard/board_nc220/board_event_log.h b/libraries/libboard/board_nc220/board_event_log.h
new file mode 100644
index 00000000..8ca64cb3
--- /dev/null
+++ b/libraries/libboard/board_nc220/board_event_log.h
@@ -0,0 +1,228 @@
+// Copyright(c) 2021-2022, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef __FPGA_BOARD_BEL_H__
+#define __FPGA_BOARD_BEL_H__
+
+#include <opae/types.h>
+
+#define BEL_SENSOR_COUNT 83
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+struct bel_header {
+	uint32_t magic;
+	uint32_t timestamp_low;
+	uint32_t timespamp_high;
+} __attribute__((__packed__));
+
+struct bel_power_on_status {
+	struct bel_header header;
+	uint32_t status;
+	uint32_t fpga_status;
+	uint32_t fpga_config_status;
+	uint32_t sequencer_status_1;
+	uint32_t sequencer_status_2;
+	uint32_t power_good_status;
+	uint32_t reserved[2];
+} __attribute__((__packed__));
+
+struct bel_power_off_status {
+	struct bel_header header;
+	uint32_t fpga_status;
+	uint32_t fpga_config_status;
+	uint32_t record_1;
+	uint32_t record_2;
+	uint32_t general_purpose_input_status;
+	uint32_t sensor_failed;
+	uint32_t sensor_alert_1;
+	uint32_t sensor_alert_2;
+	uint32_t sensor_alert_3;
+	uint32_t reserved[2];
+} __attribute__((__packed__));
+
+struct bel_sensor_state {
+	uint32_t id;
+	uint32_t reading;
+} __attribute__((__packed__));
+
+struct bel_sensors_state {
+	struct bel_header header;
+	struct bel_sensor_state sensor_state[BEL_SENSOR_COUNT];
+	uint32_t reserved[8];
+} __attribute__((__packed__));
+
+struct bel_ext_status {
+	union {
+		struct {
+			uint32_t word;
+			uint32_t vout;
+			uint32_t iout;
+			uint32_t input;
+			uint32_t temp;
+			uint32_t cml;
+		};
+		uint32_t data[6];
+	};
+} __attribute__((__packed__));
+
+struct bel_sensors_status {
+	struct bel_header header;
+	uint32_t ina3221_1_mask_enable;
+	uint32_t ina3221_2_mask_enable;
+	uint32_t ina3221_3_mask_enable;
+	struct bel_ext_status ir38062;
+	struct bel_ext_status ir38063;
+	struct bel_ext_status isl68220;
+	uint32_t ed8401_status;
+	uint32_t reserved[16];
+} __attribute__((__packed__));
+
+struct bel_timeof_day {
+	struct bel_header header;
+	uint32_t timeofday_offset_low;
+	uint32_t timeofday_offset_high;
+} __attribute__((__packed__));
+
+struct bel_max10_seu {
+	struct bel_header header;
+	uint32_t max10_seu;
+} __attribute__((__packed__));
+
+struct bel_fpga_seu {
+	struct bel_header header;
+	uint32_t fpga_seu;
+} __attribute__((__packed__));
+
+struct bel_pci_error_status {
+	struct bel_header header;
+	uint32_t pcie_link_status;
+	uint32_t pcie_uncorr_err;
+	uint32_t reserved[7];
+} __attribute__((__packed__));
+
+struct bel_pcie_v1_error_status {
+	struct bel_header header;
+	uint32_t pcie_link_status;
+	uint32_t pcie_uncorr_err;
+	uint32_t pcie_uncorr_err_mask;
+	uint32_t pcie_uncorr_err_severity;
+	uint32_t pcie_corr_err_status;
+	uint32_t pcie_corr_err_mask;
+	uint32_t pcie_cap_ctrl;
+	uint32_t pcie_header_log1;
+	uint32_t pcie_header_log2;
+	uint32_t pcie_header_log3;
+	uint32_t pcie_header_log4;
+} __attribute__((__packed__)) ;
+
+struct bel_event {
+	union {
+		struct {
+			struct bel_power_on_status power_on_status;
+			struct bel_timeof_day timeof_day;
+			struct bel_max10_seu max10_seu;
+			struct bel_fpga_seu fpga_seu;
+			struct bel_pci_error_status pci_error_status;
+			struct bel_power_off_status power_off_status;
+			struct bel_sensors_state sensors_state;
+			struct bel_sensors_status sensors_status;
+			struct bel_pcie_v1_error_status pcie_v1_error_status;
+		};
+		uint32_t data[1];
+	};
+} __attribute__((__packed__));
+
+/**
+ * Print human readable event info
+ *
+ * @param[in] event          Event structure to print
+ * @param[in] print_sensors  Flag to enable printing of the many sensors
+ * @param[in] print_sensors  Flag to enable printing of the many field bits
+ */
+void bel_print(struct bel_event *event, bool print_sensors, bool print_bits);
+
+/**
+ * Print event time span
+ *
+ * @param[in] event  Event structure to print time info for
+ * @param[in] idx    Boot counter for the passed event
+ */
+void bel_timespan(struct bel_event *event, uint32_t idx);
+
+/**
+ * Test if an event is empty
+ *
+ * @param[in] event  Event structure to test
+ *
+ * @return True if event magic is not all 0xff's
+ */
+bool bel_empty(struct bel_event *event);
+
+/**
+ * Get number of events in log on flash
+ *
+ * @return Number of events
+ */
+uint32_t bel_ptr_count(void);
+
+/**
+ * Increment index to events while handling wrap-around
+ *
+ * @param[in] ptr  Offset in log to increment from
+ *
+ * @return Offset to next event in log on flash
+ */
+uint32_t bel_ptr_next(uint32_t ptr);
+
+/**
+ * Read index of latest event in log on flash
+ *
+ * @param[in] fpga_object  Sysfs node to read from
+ * @param[out] ptr         Offset in log to read from
+ *
+ * @return FPGA_OK on success
+ */
+fpga_result bel_ptr(fpga_object fpga_object, uint32_t *ptr);
+
+/**
+ * Read event entry from log on flash
+ *
+ * @param[in] fpga_object  Sysfs node to read from
+ * @param[in] ptr          Offset in log to read from
+ * @param[out] event       Event structure to read into
+ *
+ * @return FPGA_OK on success
+ */
+fpga_result bel_read(fpga_object fpga_object, uint32_t ptr, struct bel_event *event);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __FPGA_BOARD_BEL_H__ */
diff --git a/libraries/libboard/board_nc220/board_nc220.c b/libraries/libboard/board_nc220/board_nc220.c
new file mode 100644
index 00000000..f198883f
--- /dev/null
+++ b/libraries/libboard/board_nc220/board_nc220.c
@@ -0,0 +1,956 @@
+// Copyright(c) 2021-2023, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <limits.h>
+#include <glob.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <regex.h>
+#include <opae/properties.h>
+#include <opae/utils.h>
+#include <opae/fpga.h>
+#include <netinet/ether.h>
+#include <net/ethernet.h>
+#include <opae/uio.h>
+#include "../board_common/board_common.h"
+#include "board_event_log.h"
+#include "board_nc220.h"
+#include "mock/opae_std.h"
+
+#define FPGA_VAR_BUF_LEN       256
+#define MAC_BUF_LEN            19
+#define UNUSED_PARAM(x) ((void)x)
+#define FEATURE_DEV "/sys/bus/pci/devices/*%x*:*%x*:*%x*.*%x*/fpga_region"\
+					"/region*/dfl-fme*/dfl_dev*"
+// DFL SYSFS
+#define DFL_SYSFS_BMCFW_VER                     "dfl*/bmcfw_version"
+#define DFL_SYSFS_MAX10_VER                     "dfl*/bmc_version"
+
+#define DFL_SYSFS_MACADDR_PATH                  "dfl*/mac_address"
+#define DFL_SYSFS_MACCNT_PATH                   "dfl*/mac_count"
+
+#define DFL_SEC_PMCI_GLOB "*dfl*/**/security/"
+#define DFL_SEC_USER_FLASH_COUNT  DFL_SEC_PMCI_GLOB "*flash_count"
+#define DFL_SEC_BMC_CANCEL        DFL_SEC_PMCI_GLOB "bmc_canceled_csks"
+#define DFL_SEC_BMC_ROOT          DFL_SEC_PMCI_GLOB "bmc_root_entry_hash"
+#define DFL_SEC_PR_CANCEL         DFL_SEC_PMCI_GLOB "pr_canceled_csks"
+#define DFL_SEC_PR_ROOT           DFL_SEC_PMCI_GLOB "pr_root_entry_hash"
+#define DFL_SEC_SR_CANCEL         DFL_SEC_PMCI_GLOB "sr_canceled_csks"
+#define DFL_SEC_SR_ROOT           DFL_SEC_PMCI_GLOB "sr_root_entry_hash"
+#define DFL_SEC_PR_SDM_CANCEL     DFL_SEC_PMCI_GLOB "pr_sdm_canceled_csks"
+#define DFL_SEC_PR_SDM_ROOT       DFL_SEC_PMCI_GLOB "pr_sdm_root_entry_hash"
+#define DFL_SEC_SR_SDM_CANCEL     DFL_SEC_PMCI_GLOB "sr_sdm_canceled_csks"
+#define DFL_SEC_SR_SDM_ROOT       DFL_SEC_PMCI_GLOB "sr_sdm_root_entry_hash"
+
+
+#define HSSI_FEATURE_ID                  0x15
+#define HSSI_100G_PROFILE                       27
+#define HSSI_25G_PROFILE                        21
+#define HSSI_10_PROFILE                         20
+
+#define HSSI_FEATURE_LIST                       0xC
+#define HSSI_PORT_ATTRIBUTE                     0x10
+#define HSSI_VERSION                            0x8
+#define HSSI_PORT_STATUS                        0x818
+
+// boot page info sysfs
+#define DFL_SYSFS_BOOT_GLOB "*dfl*/**/fpga_boot_image"
+#define BOOTPAGE_PATTERN "_([0-9a-zA-Z]+)"
+
+// image info sysfs
+#define DFL_SYSFS_IMAGE_INFO_GLOB "*dfl*/**/fpga_image_directory*/nvmem"
+#define IMAGE_INFO_STRIDE 4096
+#define IMAGE_INFO_SIZE     32
+#define IMAGE_INFO_COUNT     3
+#define GET_BIT(var, pos) ((var >> pos) & (1))
+
+// event log
+#define DFL_SYSFS_EVENT_LOG_GLOB "*dfl*/**/bmc_event_log*/nvmem"
+
+// BOM info
+#define DFL_SYSFS_BOM_INFO_GLOB "*dfl*/**/bom_info*/nvmem"
+#define FPGA_BOM_INFO_BUF_LEN   0x2000
+
+#define DFH_CSR_ADDR                  0x18
+#define DFH_CSR_SIZE                  0x20
+
+// hssi version
+struct hssi_version {
+	union {
+		uint32_t csr;
+		struct {
+			uint32_t rsvd : 8;
+			uint32_t minor : 8;
+			uint32_t major : 16;
+		};
+	};
+};
+
+//Physical Port Enable
+/*
+[6] - Port 0 Enable
+[7] - Port 1 Enable
+:
+[21] - Port 15 Enable
+*/
+#define PORT_ENABLE_COUNT 20
+
+// hssi feature list CSR
+struct hssi_feature_list {
+	union {
+		uint32_t csr;
+		struct {
+			uint32_t axi4_support : 1;
+			uint32_t hssi_num : 5;
+			uint32_t port_enable : 20;
+			uint32_t reserved : 6;
+		};
+	};
+};
+
+// hssi port attribute CSR
+//Interface Attribute Port X Parameters, X =0-15
+//Byte Offset: 0x10 + X * 4
+struct hssi_port_attribute {
+	union {
+		uint32_t csr;
+		struct {
+			uint32_t profile : 6;
+			uint32_t ready_latency : 4;
+			uint32_t data_bus_width : 3;
+			uint32_t low_speed_mac : 2;
+			uint32_t dynamic_pr : 1;
+			uint32_t sub_profile : 5;
+			uint32_t reserved : 11;
+		};
+	};
+};
+
+//HSSI Ethernet Port Status
+//Byte Offset: 0x818
+struct hssi_port_status {
+	union {
+		uint64_t csr;
+		struct {
+			uint64_t txplllocked : 16;
+			uint64_t txlanestable : 16;
+			uint64_t rxpcsready : 16;
+			uint64_t reserved : 16;
+		};
+	};
+};
+
+
+struct dfh {
+	union {
+		uint64_t csr;
+		struct {
+			uint64_t id : 12;
+			uint64_t feature_rev : 4;
+			uint64_t next : 24;
+			uint64_t eol : 1;
+			uint64_t reserved41 : 7;
+			uint64_t feature_minor_rev : 4;
+			uint64_t dfh_version : 8;
+			uint64_t type : 4;
+		};
+	};
+};
+
+struct dfh_csr_addr {
+	union {
+		uint32_t csr;
+		struct {
+			uint64_t rel : 1;
+			uint64_t addr : 63;
+		};
+	};
+};
+
+struct dfh_csr_group {
+	union {
+		uint32_t csr;
+		struct {
+			uint64_t instance_id : 16;
+			uint64_t grouping_id : 15;
+			uint64_t has_params : 1;
+			uint64_t csr_size : 32;
+		};
+	};
+};
+
+
+
+typedef struct hssi_port_profile {
+
+	uint32_t port_index;
+	char profile[FPGA_VAR_BUF_LEN];
+
+} hssi_port_profile;
+
+#define HSS_PORT_PROFILE_SIZE 34
+
+hssi_port_profile hssi_port_profiles[] = {
+
+	{.port_index = 0, .profile = "LL100G"},
+	{.port_index = 1, .profile = "Ultra100G"},
+	{.port_index = 2, .profile = "LL50G"},
+	{.port_index = 3, .profile = "LL40G"},
+	{.port_index = 4, .profile = "Ultra40G"},
+	{.port_index = 5, .profile = "25_50G"},
+	{.port_index = 6, .profile = "10_25G"},
+	{.port_index = 7, .profile = "MRPHY"},
+	{.port_index = 8, .profile = "LL10G"},
+	{.port_index = 9, .profile = "TSE PCS"},
+	{.port_index = 10, .profile = "TSE MAC"},
+	{.port_index = 11, .profile = "Flex-E"},
+	{.port_index = 12, .profile = "OTN"},
+	{.port_index = 13, .profile = "General PCS-Direct"},
+	{.port_index = 14, .profile = "General FEC-Direct"},
+	{.port_index = 15, .profile = "General PMA-Direct"},
+	{.port_index = 16, .profile = "MII"},
+	{.port_index = 17, .profile = "Ethernet PCS-Direct"},
+	{.port_index = 18, .profile = "Ethernet FEC-Direct"},
+	{.port_index = 19, .profile = "Ethernet PMA-Direct"},
+	{.port_index = 20, .profile = "10GbE"},
+	{.port_index = 21, .profile = "25GbE"},
+	{.port_index = 22, .profile = "40GCAUI-4"},
+	{.port_index = 23, .profile = "50GAUI-2"},
+	{.port_index = 24, .profile = "50GAUI-1"},
+	{.port_index = 25, .profile = "100GAUI-1"},
+	{.port_index = 26, .profile = "100GAUI-2"},
+	{.port_index = 27, .profile = "100GCAUI-4"},
+	{.port_index = 28, .profile = "200GAUI-2"},
+	{.port_index = 29, .profile = "200GAUI-4"},
+	{.port_index = 30, .profile = "200GAUI-8"},
+	{.port_index = 31, .profile = "400GAUI-4"},
+	{.port_index = 32, .profile = "400GAUI-8"},
+	{.port_index = 33, .profile = "CPRI"}
+ };
+
+
+// Parse firmware version
+fpga_result parse_fw_ver(char *buf, char *fw_ver, size_t len)
+{
+	uint32_t  var = 0;
+	fpga_result res = FPGA_OK;
+	int retval = 0;
+	char *endptr = NULL;
+
+	if (buf == NULL || fw_ver == NULL) {
+		OPAE_ERR("Invalid Input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	/* BMC FW version format reading
+	NIOS II Firmware Build 0x0 32 RW[23:0] 24 hFFFFFF Build version of NIOS II Firmware
+	NIOS FW is up e.g. 1.0.1 for first release
+	[31:24] 8hFF Firmware Support Revision - ASCII code
+	0xFF is the default value without NIOS FW, will be changed after NIOS FW is up
+	*/
+
+	errno = 0;
+	var = strtoul(buf, &endptr, 16);
+	if (endptr != buf + strlen(buf)) {
+		OPAE_ERR("Failed to convert buffer to integer: %s", strerror(errno));
+		return FPGA_EXCEPTION;
+	}
+
+	retval = snprintf(fw_ver, len, "%u.%u.%u", (var >> 16) & 0xff, (var >> 8) & 0xff, var & 0xff);
+	if (retval < 0) {
+		OPAE_ERR("error in formatting version");
+		return FPGA_EXCEPTION;
+	}
+
+	return res;
+}
+
+// Read BMC firmware version
+fpga_result read_bmcfw_version(fpga_token token, char *bmcfw_ver, size_t len)
+{
+	fpga_result res = FPGA_OK;
+	char buf[FPGA_VAR_BUF_LEN] = { 0 };
+
+	if (bmcfw_ver == NULL) {
+		OPAE_ERR("Invalid Input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	res = read_sysfs(token, DFL_SYSFS_BMCFW_VER, buf, FPGA_VAR_BUF_LEN - 1);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to get read object");
+		return res;
+	}
+
+	res = parse_fw_ver(buf, bmcfw_ver, len);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to parse version ");
+	}
+
+	return res;
+}
+
+
+// Read MAX10 firmware version
+fpga_result read_max10fw_version(fpga_token token, char *max10fw_ver, size_t len)
+{
+	fpga_result res = FPGA_OK;
+	char buf[FPGA_VAR_BUF_LEN] = { 0 };
+
+	if (max10fw_ver == NULL) {
+		OPAE_ERR("Invalid Input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	res = read_sysfs(token, DFL_SYSFS_MAX10_VER, buf, FPGA_VAR_BUF_LEN - 1);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to get read object");
+		return res;
+	}
+
+	res = parse_fw_ver(buf, max10fw_ver, len);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to parse version ");
+	}
+
+	return res;
+}
+
+// print mac information
+fpga_result print_mac_info(fpga_token token)
+{
+	fpga_result res = FPGA_OK;
+	char buf[MAC_BUF_LEN] = { 0 };
+	char count[MAC_BUF_LEN] = { 0 };
+	int n = 0;
+	char *endptr = NULL;
+	struct ether_addr mac_addr ;
+	memset(&mac_addr, 0, sizeof(mac_addr));
+
+	res = read_sysfs(token, DFL_SYSFS_MACADDR_PATH, (char *)buf, MAC_BUF_LEN - 1);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to read mac information");
+		return res;
+	}
+
+	ether_aton_r(buf, &mac_addr);
+
+	res = read_sysfs(token, DFL_SYSFS_MACCNT_PATH, (char *)count, MAC_BUF_LEN - 1);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to read mac information");
+		return res;
+	}
+
+	errno = 0;
+	n = strtol(count, &endptr, 10);
+	if (endptr != count + strlen(count)) {
+		OPAE_ERR("Failed to convert buffer to integer: %s", strerror(errno));
+		return FPGA_EXCEPTION;
+	}
+	printf("%-32s : %d\n", "Number of MACs", n);
+
+	if (n < 0 || n > 0xFFFF) {
+		OPAE_ERR("Invalid mac count");
+		return FPGA_EXCEPTION;
+	}
+
+	if ((mac_addr.ether_addr_octet[0] == 0xff) &&
+		(mac_addr.ether_addr_octet[1] == 0xff) &&
+		(mac_addr.ether_addr_octet[2] == 0xff) &&
+		(mac_addr.ether_addr_octet[3] == 0xff) &&
+		(mac_addr.ether_addr_octet[4] == 0xff) &&
+		(mac_addr.ether_addr_octet[5] == 0xff)) {
+		OPAE_ERR("Invalid MAC address");
+		return FPGA_EXCEPTION;
+	}
+
+	print_mac_address(&mac_addr, n);
+
+	return res;
+}
+
+// Read BOM Critical Components info from the FPGA
+static fpga_result read_bom_info(
+	const fpga_token token,
+	char * const bom_info,
+	const size_t len)
+{
+	if (bom_info == NULL)
+		return FPGA_INVALID_PARAM;
+
+	fpga_result resval = FPGA_OK;
+	fpga_object fpga_object;
+
+	fpga_result res = fpgaTokenGetObject(token, DFL_SYSFS_BOM_INFO_GLOB,
+					     &fpga_object, FPGA_OBJECT_GLOB);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to get token Object");
+		// Simulate reading of empty BOM info filled with 0xFF
+		// so that FPGA with no BOM info produces no output.
+		// Return FPGA_OK!
+		memset(bom_info, 0xFF, len);
+		return FPGA_OK;
+	}
+
+	res = fpgaObjectRead(fpga_object, (uint8_t *)bom_info, 0, len, FPGA_OBJECT_RAW);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to read BOM info");
+		memset(bom_info, 0xFF, len); // Simulate reading of empty BOM info filled with 0xFF
+		resval = res;
+	}
+
+	res = fpgaDestroyObject(&fpga_object);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to Destroy Object");
+		if (resval == FPGA_OK)
+			resval = res;
+	}
+
+	return resval;
+}
+
+
+// print BOM info
+fpga_result print_bom_info(const fpga_token token)
+{
+	fpga_result resval = FPGA_OK;
+	const size_t max_result_len = 2 * FPGA_BOM_INFO_BUF_LEN;
+	char * const bom_info = (char *)opae_malloc(max_result_len);
+
+	if (bom_info == NULL)
+		return FPGA_NO_MEMORY;
+
+	fpga_result res = read_bom_info(token, bom_info, FPGA_BOM_INFO_BUF_LEN);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to read BOM info");
+		opae_free(bom_info);
+		return res;
+	}
+
+	// Terminated by a null character '\0'
+	bom_info[FPGA_BOM_INFO_BUF_LEN] = '\0';
+
+	res = reformat_bom_info(bom_info, FPGA_BOM_INFO_BUF_LEN, max_result_len);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to reformat BOM info");
+		if (resval == FPGA_OK)
+			resval = res;
+	}
+
+	printf("%s", bom_info);
+
+	opae_free(bom_info);
+
+	return resval;
+}
+
+// print board information
+fpga_result print_board_info(fpga_token token)
+{
+	fpga_result res = FPGA_OK;
+	fpga_result resval = FPGA_OK;
+	char bmc_ver[FPGA_VAR_BUF_LEN] = { 0 };
+	char max10_ver[FPGA_VAR_BUF_LEN] = { 0 };
+
+	res = read_bmcfw_version(token, bmc_ver, FPGA_VAR_BUF_LEN);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to read bmc version");
+		resval = res;
+	}
+
+	res = read_max10fw_version(token, max10_ver, FPGA_VAR_BUF_LEN);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to read max10 version");
+		resval = res;
+	}
+
+	printf("Board Management Controller NIOS FW version: %s \n", bmc_ver);
+	printf("Board Management Controller Build version: %s \n", max10_ver);
+
+	res = print_bom_info(token);
+	if (res != FPGA_OK) {
+		OPAE_ERR("Failed to print BOM info");
+		if (resval == FPGA_OK)
+			resval = res;
+	}
+
+	return resval;
+}
+
+// print phy group information
+fpga_result print_phy_info(fpga_token token)
+{
+	fpga_result res = FPGA_OK;
+	struct opae_uio uio;
+	char feature_dev[SYSFS_PATH_MAX] = { 0 };
+	uint8_t *mmap_ptr = NULL;
+
+	res = qsfp_cable_status(token);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to find QSFP cable info");
+	}
+
+	res = find_dev_feature(token, HSSI_FEATURE_ID, feature_dev);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to find feature HSSI");
+		return res;
+	}
+
+	res = opae_uio_open(&uio, feature_dev);
+	if (res) {
+		OPAE_ERR("Failed to open uio");
+		return res;
+	}
+
+	res = opae_uio_region_get(&uio, 0, (uint8_t **)&mmap_ptr, NULL);
+	if (res) {
+		OPAE_ERR("Failed to get uio region");
+		opae_uio_close(&uio);
+		return res;
+	}
+
+	res = print_hssi_port_status(mmap_ptr);
+	if (res) {
+		OPAE_ERR("Failed to read hssi port status");
+	}
+
+	opae_uio_close(&uio);
+	return res;
+}
+
+// Sec info
+fpga_result print_sec_info(fpga_token token)
+{
+	fpga_result res = FPGA_OK;
+	fpga_result resval = FPGA_OK;
+	fpga_object tcm_object;
+	char name[SYSFS_PATH_MAX] = { 0 };
+
+	res = fpgaTokenGetObject(token, DFL_SEC_PMCI_GLOB, &tcm_object,
+		FPGA_OBJECT_GLOB);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to get token Object");
+		return res;
+	}
+	printf("********** SEC Info START ************ \n");
+
+	// BMC Keys
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_BMC_ROOT, name, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "BMC root entry hash", name);
+	} else {
+		OPAE_MSG("Failed to Read TCM BMC root entry hash");
+		printf("%-32s : %s\n", "BMC root entry hash", "None");
+		resval = res;
+	}
+
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_BMC_CANCEL, name, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "BMC CSK IDs canceled",
+				strlen(name) > 0 ? name : "None");
+	} else {
+		OPAE_MSG("Failed to Read BMC CSK IDs canceled");
+		printf("%-32s : %s\n", "BMC CSK IDs canceled", "None");
+		resval = res;
+	}
+
+	// PR Keys
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_PR_ROOT, name, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "PR root entry hash", name);
+	} else {
+		OPAE_MSG("Failed to Read PR root entry hash");
+		printf("%-32s : %s\n", "PR root entry hash", "None");
+		resval = res;
+	}
+
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_PR_CANCEL, name, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "AFU/PR CSK IDs canceled",
+			strlen(name) > 0 ? name : "None");
+	} else {
+		OPAE_MSG("Failed to Read AFU CSK/PR IDs canceled");
+		printf("%-32s : %s\n", "AFU/PR CSK IDs canceled", "None");
+		resval = res;
+	}
+
+	// SR Keys
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_SR_ROOT, name, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "FIM root entry hash", name);
+	} else {
+		OPAE_MSG("Failed to Read FIM root entry hash");
+		printf("%-32s : %s\n", "FIM root entry hash", "None");
+		resval = res;
+	}
+
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_SR_CANCEL, name, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "FIM CSK IDs canceled",
+			strlen(name) > 0 ? name : "None");
+	} else {
+		OPAE_MSG("Failed to Read FIM CSK IDs canceled");
+		printf("%-32s : %s\n", "FIM CSK IDs canceled", "None");
+		resval = res;
+	}
+
+	// User flash count
+	memset(name, 0, sizeof(name));
+	res = read_sysfs(token, DFL_SEC_USER_FLASH_COUNT, name,
+		SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "User flash update counter", name);
+	} else {
+		OPAE_MSG("Failed to Read User flash update counter");
+		printf("%-32s : %s\n", "User flash update counter", "None");
+		resval = res;
+	}
+
+	// PR SDM Keys
+	res = read_sysfs(token, DFL_SEC_PR_SDM_CANCEL, name,
+		SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "PR SDM CSK IDs canceled", name);
+	} else {
+		OPAE_MSG("Failed to PR SDM CSK IDs canceled");
+		printf("%-32s : %s\n", "PR SDM CSK IDs canceled", "None");
+		resval = res;
+	}
+
+	res = read_sysfs(token, DFL_SEC_PR_SDM_ROOT, name,
+		SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "PR SDM root entry hash", name);
+	} else {
+		OPAE_MSG("Failed to PR SDM root entry hash");
+		printf("%-32s : %s\n", "PR SDM root entry hash", "None");
+		resval = res;
+	}
+
+	// SR SDM Keys
+	res = read_sysfs(token, DFL_SEC_SR_SDM_CANCEL, name,
+		SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "SR SDM CSK IDs canceled", name);
+	} else {
+		OPAE_MSG("Failed to SR SDM CSK IDs canceled");
+		printf("%-32s : %s\n", "SR SDM CSK IDs canceled", "None");
+		resval = res;
+	}
+
+	res = read_sysfs(token, DFL_SEC_SR_SDM_ROOT, name,
+		SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+		printf("%-32s : %s\n", "SR SDM root entry hash", name);
+	} else {
+		OPAE_MSG("Failed to SR SDM root entry hash");
+		printf("%-32s : %s\n", "SR SDM root entry hash", "None");
+		resval = res;
+	}
+
+	res = fpgaDestroyObject(&tcm_object);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to Destroy Object");
+		resval = res;
+	}
+
+	printf("********** SEC Info END ************ \n");
+
+	return resval;
+}
+
+
+// prints fpga boot page info
+fpga_result fpga_boot_info(fpga_token token)
+{
+	char boot[SYSFS_PATH_MAX] = { 0 };
+	char page[SYSFS_PATH_MAX] = { 0 };
+	fpga_result res           = FPGA_OK;
+	int reg_res               = 0;
+	char err[128]           = { 0 };
+	regex_t re;
+	regmatch_t matches[3];
+
+	// boot page
+	memset(boot, 0, sizeof(boot));
+	res = read_sysfs(token, DFL_SYSFS_BOOT_GLOB, boot, SYSFS_PATH_MAX - 1);
+	if (res == FPGA_OK) {
+
+		reg_res = regcomp(&re, BOOTPAGE_PATTERN, REG_EXTENDED | REG_ICASE);
+		if (reg_res) {
+			OPAE_ERR("Error compiling regex");
+			return FPGA_EXCEPTION;
+		}
+
+		reg_res = regexec(&re, boot, 3, matches, 0);
+		if (reg_res) {
+			regerror(reg_res, &re, err, sizeof(err));
+			OPAE_MSG("Error executing regex: %s", err);
+			regfree(&re);
+			return FPGA_EXCEPTION;
+		}
+		memcpy(page, boot + matches[0].rm_so + 1,
+			matches[0].rm_eo - (matches[0].rm_so + 1));
+		page[matches[0].rm_eo - (matches[0].rm_so + 1)] = '\0';
+
+		printf("%-32s : %s\n", "Boot Page", page);
+		regfree(&re);
+	} else {
+		OPAE_MSG("Failed to Read Boot Page");
+		printf("%-32s : %s\n", "Boot Page", "N/A");
+	}
+
+	return res;
+}
+
+// prints fpga image info
+fpga_result fpga_image_info(fpga_token token)
+{
+	const char *image_info_label[IMAGE_INFO_COUNT] = {
+		"Factory Image Info",
+		"User1 Image Info",
+		"User2 Image Info",
+	};
+	fpga_object fpga_object;
+	fpga_result res;
+	size_t i;
+
+	res = fpgaTokenGetObject(token, DFL_SYSFS_IMAGE_INFO_GLOB,
+			&fpga_object, FPGA_OBJECT_GLOB);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to get token Object");
+		return res;
+	}
+
+	for (i = 0; i < IMAGE_INFO_COUNT; i++) {
+		size_t offset = IMAGE_INFO_STRIDE * i;
+		uint8_t data[IMAGE_INFO_SIZE + 1] = { 0 };
+		char *image_info = (char *)data;
+		size_t p;
+
+		printf("%-32s : ", image_info_label[i]);
+
+		res = fpgaObjectRead(fpga_object, data, offset,
+				IMAGE_INFO_SIZE, FPGA_OBJECT_RAW);
+		if (res != FPGA_OK) {
+			printf("N/A\n");
+			continue;
+		}
+
+		for (p = 0; p < IMAGE_INFO_SIZE; p++)
+			if (data[p] != 0xff)
+				break;
+
+		if (p >= IMAGE_INFO_SIZE) {
+			printf("None\n");
+			continue;
+		}
+
+		if (strlen(image_info) == 0) {
+			printf("Empty\n");
+			continue;
+		}
+
+		printf("%s\n", image_info);
+	}
+
+	if (fpgaDestroyObject(&fpga_object) != FPGA_OK)
+		OPAE_ERR("Failed to Destroy Object");
+
+	return res;
+}
+
+fpga_result fpga_event_log(fpga_token token, uint32_t first, uint32_t last,
+	bool print_list, bool print_sensors, bool print_bits)
+{
+	fpga_object fpga_object;
+	struct bel_event event;
+	uint32_t count = last;
+	uint32_t i = first;
+	fpga_result res;
+	uint32_t ptr;
+
+	memset(&event, 0, sizeof(event));
+
+	if (first > bel_ptr_count()) {
+		fprintf(stderr, "invalid --boot value: %u\n", first);
+		return FPGA_INVALID_PARAM;
+	}
+
+	if (last > bel_ptr_count()) {
+		fprintf(stderr, "invalid --boot + --count value: %u\n", last);
+		return FPGA_INVALID_PARAM;
+	}
+
+	res = fpgaTokenGetObject(token, DFL_SYSFS_EVENT_LOG_GLOB,
+			&fpga_object, FPGA_OBJECT_GLOB);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to get token Object");
+		return res;
+	}
+
+	/* Special case when all events requested */
+	if (first == last) {
+		count = bel_ptr_count();
+		i = 0;
+	}
+
+	/* Get index to latest log event in flash */
+	res = bel_ptr(fpga_object, &ptr);
+	if (res != FPGA_OK) {
+		OPAE_MSG("Failed to read log pointer");
+		goto out;
+	}
+
+	/* Fast forward to the requested event */
+	while (first--)
+		ptr = bel_ptr_next(ptr);
+
+	/* Read and print the requested number of events */
+	while (i++ < count) {
+		res = bel_read(fpga_object, ptr, &event);
+		if (res != FPGA_OK)
+			goto out;
+
+		if (print_list) {
+			bel_timespan(&event, i - 1);
+		} else if (bel_empty(&event)) {
+			if ((i - 1) == 0)
+				printf("Current Boot / Boot %i: Empty\n", i - 1);
+			else
+				printf("Boot %i: Empty\n", i - 1);
+
+		} else {
+			if ((i - 1) == 0)
+				printf("Current Boot / Boot %i\n", i - 1);
+			else
+				printf("Boot %i\n", i - 1);
+			bel_print(&event, print_sensors, print_bits);
+		}
+
+		ptr = bel_ptr_next(ptr);
+	}
+
+out:
+	if (fpgaDestroyObject(&fpga_object) != FPGA_OK)
+		OPAE_ERR("Failed to Destroy Object");
+
+	return FPGA_OK;
+}
+
+fpga_result print_hssi_port_status(uint8_t *uio_ptr)
+{
+	uint32_t i                     = 0;
+	uint32_t k                     = 0;
+	uint32_t ver_offset            = 0;
+	uint32_t feature_list_offset   = 0;
+	uint32_t port_sts_offset       = 0;
+	uint32_t port_attr_offset      = 0;
+	struct dfh dfh_csr;
+	struct dfh_csr_addr csr_addr;
+	struct hssi_port_attribute port_profile;
+	struct hssi_feature_list  feature_list;
+	struct hssi_version  hssi_ver;
+	struct hssi_port_status port_status;
+
+	if (uio_ptr == NULL) {
+		OPAE_ERR("Invalid Input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	dfh_csr.csr = *((uint64_t *)(uio_ptr + 0x0));
+	// dfhv0
+	if ((dfh_csr.feature_rev == 0) ||
+		(dfh_csr.feature_rev == 0x1)) {
+		ver_offset = HSSI_VERSION;
+		feature_list_offset = HSSI_FEATURE_LIST;
+		port_sts_offset = HSSI_PORT_STATUS;
+		port_attr_offset = HSSI_PORT_ATTRIBUTE;
+	} else if ((dfh_csr.feature_rev >= 0x2) && (dfh_csr.feature_rev < 0xf)) { // dfhv0.5
+		csr_addr.csr = *((uint64_t *)(uio_ptr + DFH_CSR_ADDR));
+		ver_offset = csr_addr.addr;
+		feature_list_offset = csr_addr.addr + 0x4;
+		port_sts_offset = HSSI_PORT_STATUS;
+		port_attr_offset = csr_addr.addr + 0x8;
+
+	} else {
+		printf("DFH feature revision not supported:%x \n", dfh_csr.feature_rev);
+		return FPGA_NOT_SUPPORTED;
+	}
+
+	feature_list.csr = *((uint32_t *)(uio_ptr + feature_list_offset));
+	hssi_ver.csr = *((uint32_t *)(uio_ptr + ver_offset));
+	port_status.csr = *((volatile uint64_t *)(uio_ptr
+		+ port_sts_offset));
+
+	printf("//****** HSSI information ******//\n");
+	printf("%-32s : %d.%d  \n", "HSSI version", hssi_ver.major, hssi_ver.minor);
+	printf("%-32s : %d  \n", "Number of ports", feature_list.hssi_num);
+
+	for (i = 0; i < PORT_ENABLE_COUNT; i++) {
+
+		// prints only active/enabled ports
+		if ((GET_BIT(feature_list.port_enable, i) == 0)) {
+			continue;
+		}
+
+		port_profile.csr = *((volatile uint32_t *)(uio_ptr +
+			port_attr_offset + i * 4));
+
+		if (port_profile.profile > HSS_PORT_PROFILE_SIZE) {
+			printf("Port%-28d :%s\n", i, "N/A");
+			continue;
+		}
+
+		for (int j = 0; j < HSS_PORT_PROFILE_SIZE; j++) {
+			if (hssi_port_profiles[j].port_index == port_profile.profile) {
+				// lock, tx, rx bits set - link status UP
+				// lock, tx, rx bits not set - link status DOWN
+				if ((GET_BIT(port_status.txplllocked, k) == 1) &&
+					(GET_BIT(port_status.txlanestable, k) == 1) &&
+					(GET_BIT(port_status.rxpcsready, k) == 1)) {
+					printf("Port%-28d :%-12s %s\n", i,
+						hssi_port_profiles[j].profile, "UP");
+				} else {
+					printf("Port%-28d :%-12s %s\n", i,
+						hssi_port_profiles[j].profile, "DOWN");
+				}
+				k++;
+				break;
+			}
+		}
+	}
+
+	return FPGA_OK;
+}
diff --git a/libraries/libboard/board_nc220/board_nc220.h b/libraries/libboard/board_nc220/board_nc220.h
new file mode 100644
index 00000000..5ab5f66c
--- /dev/null
+++ b/libraries/libboard/board_nc220/board_nc220.h
@@ -0,0 +1,159 @@
+// Copyright(c) 2021, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef __FPGA_BOARD_NC220_H__
+#define __FPGA_BOARD_NC220_H__
+
+#include <opae/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+* Get Max10 firmware version.
+*
+* @param[in] token           fpga_token object for device (FPGA_DEVICE type)
+* @param[inout] max10fw_var  pointer to char pcb_info string
+*                            user allocates memory and free input string
+* @param[in] len             length of char max10fw_var string
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if MAX10  sysfs not found.
+* FPGA_INVALID_PARAM if invalid parameters were provide
+*
+*/
+fpga_result read_max10fw_version(fpga_token token, char *max10fw_var, size_t len);
+
+/**
+* Get BMC/NIOS firmware version.
+*
+* @param[in] token           fpga_token object for device (FPGA_DEVICE type)
+* @param[inout] bmcfw_var    pointer to char bmcfw_var string
+*                            user allocates memory and free input string
+* @param[in] len             length of char bmcfw_var string
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if NIOS sysfs not found.
+* FPGA_INVALID_PARAM if invalid parameters were provide
+*
+*/
+fpga_result read_bmcfw_version(fpga_token token, char *bmcfw_var, size_t len);
+
+/**
+* Parse bmc/max10 version.
+*
+* @param[in] buf             pointer to firmware version
+* @param[inout] fw_ver       pointer to char firmware string
+* @param[in] len             length of char fw var string
+* @returns FPGA_OK on success. FPGA_EXCEPTION if FW version is invlaid.
+*
+*/
+fpga_result parse_fw_ver(char *buf, char *fw_ver, size_t len);
+
+
+/**
+* Prints BMC, MAX10 and NIOS version.
+*
+* @param[in] token            fpga_token object for device (FPGA_DEVICE type)
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if MAX10 or NIOS sysfs not found.
+* FPGA_INVALID_PARAM if invalid parameters were provide
+*
+*/
+fpga_result print_board_info(fpga_token token);
+
+/**
+* Prints phy group informantion.
+*
+* @param[in] token            fpga_token object for device (FPGA_DEVICE type)
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if phy group sysfs not found.
+* FPGA_INVALID_PARAM if invalid parameters were provide
+*
+*/
+fpga_result print_phy_info(fpga_token token);
+
+/**
+* Prints mac informantion.
+*
+* @param[in] token            fpga_token object for device (FPGA_DEVICE type)
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if mac sysfs not found.
+* FPGA_INVALID_PARAM if invalid parameters were provide
+*
+*/
+fpga_result print_mac_info(fpga_token token);
+
+/**
+* Prints Security information.
+*
+* @param[in] token            fpga_token object for device (FPGA_DEVICE type)
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if Security sysfs not found.
+* FPGA_INVALID_PARAM if invalid parameters were provided
+*/
+fpga_result print_sec_info(fpga_token token);
+
+
+/**
+* Prints fpga boot page info.
+*
+* @param[in] token           fpga_token object for device (FPGA_DEVICE type)
+* @returns FPGA_OK on success. FPGA_NOT_FOUND if invalid boot info.
+* FPGA_INVALID_PARAM if invalid parameters were provided
+*
+*/
+fpga_result fpga_boot_info(fpga_token token);
+
+/**
+* Prints fpga image info.
+*
+* @param[in] token           fpga_token object for device (FPGA_DEVICE type)
+* @returns FPGA_OK on success, or FPGA_NOT_FOUND if the sysfs node is not found.
+*/
+fpga_result fpga_image_info(fpga_token token);
+
+/**
+* Prints fpga event log.
+*
+* @param[in] token           fpga_token object for device (FPGA_DEVICE type)
+* @param[in] first           first boot indenx to print
+* @param[in] last            (one past) last boot index to print
+* @param[in] print_list      print power-on and power-off datetime only
+* @param[in] print_sensors   print sensor data too
+* @param[in] print_bits      print bit fields verbosely too
+* @returns FPGA_OK on success, or FPGA_NOT_FOUND if the sysfs node is not found.
+*/
+fpga_result fpga_event_log(fpga_token token, uint32_t first, uint32_t last,
+	bool print_list, bool print_sensors, bool print_bits);
+
+/**
+* Prints hssi port status.
+*
+* @param[in] uio_ptr          dfh uio mmap ptr
+* @returns FPGA_OK on success, or FPGA_NOT_SUPPORTED if dfh version found.
+*/
+fpga_result print_hssi_port_status(uint8_t *uio_ptr);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __FPGA_BOARD_NC220_H__ */
diff --git a/libraries/libopae-c/cfg-file.c b/libraries/libopae-c/cfg-file.c
index 69d37278..630ed032 100644
--- a/libraries/libopae-c/cfg-file.c
+++ b/libraries/libopae-c/cfg-file.c
@@ -430,8 +430,11 @@ STATIC fpgainfo_config_data default_fpgainfo_config_table[] = {
 	{ 0x8086, 0xbcce, 0x8086, 0x1770, 0x12, "libboard_n6000.so", NULL,
 	"Intel Acceleration Development Platform N6000" },
 
-	{ 0x8086, 0xbcce, 0x8086, 0x1771, 0x12, "libboard_n6000.so", NULL,
-	"Intel Acceleration Development Platform N6001" },
+	{ 0x8086, 0xbcce, 0x8086, 0x1771, 0x12, "libboard_nc220.so", NULL,
+	"Intel Open FPGA Stack Platform NC220" },
+
+	//{ 0x8086, 0xbcce, 0x8086, 0x1771, 0x12, "libboard_n6000.so", NULL,
+	//"Intel Acceleration Development Platform N6001" },
 
 	{ 0x8086, 0xbcce, 0x8086, 0x17d4, 0x12, "libboard_c6100.so", NULL,
 	"Intel IPU Platform F2000X-PL" },
diff --git a/opae.cfg b/opae.cfg
index 98ca5f1b..afda17f5 100644
--- a/opae.cfg
+++ b/opae.cfg
@@ -495,13 +495,13 @@
       }
     },
 
-    "n6001": {
+    "nc220": {
       "enabled": true,
-      "platform": "Intel Acceleration Development Platform N6001",
+      "platform": "Intel Open FPGA Stack Platform NC220",
 
       "devices": [
-        { "name": "n6001_pf", "id": [ "0x8086", "0xbcce", "0x8086", "0x1771" ] },
-        { "name": "n6001_vf", "id": [ "0x8086", "0xbccf", "0x8086", "0x1771" ] }
+        { "name": "nc220_pf", "id": [ "0x8086", "0xbcce", "0x8086", "0x1771" ] },
+        { "name": "nc220_vf", "id": [ "0x8086", "0xbccf", "0x8086", "0x1771" ] }
       ],
 
       "opae": {
@@ -509,29 +509,29 @@
           {
             "enabled": true,
             "module": "libxfpga.so",
-            "devices": [ "n6001_pf" ],
+            "devices": [ "nc220_pf" ],
             "configuration": {}
           },
           {
             "enabled": true,
             "module": "libopae-v.so",
-            "devices": [ "n6001_pf", "n6001_vf" ],
+            "devices": [ "nc220_pf", "nc220_vf" ],
             "configuration": {}
           },
           {
             "enabled": true,
             "module": "libopae-u.so",
-            "devices": [ "n6001_pf", "n6001_vf" ],
+            "devices": [ "nc220_pf", "nc220_vf" ],
             "configuration": {}
           }
         ],
         "fpgainfo": [
           {
             "enabled": true,
-            "module": "libboard_n6000.so",
+            "module": "libboard_nc220.so",
             "devices": [
-              { "device": "n6001_pf", "feature_id": "0x12" },
-              { "device": "n6001_vf", "feature_id": "0x12" }
+              { "device": "nc220_pf", "feature_id": "0x12" },
+              { "device": "nc220_vf", "feature_id": "0x12" }
             ]
           }
         ],
@@ -539,7 +539,7 @@
           {
             "enabled": true,
             "module": "libfpgad-vc.so",
-            "devices": [ "n6001_pf" ],
+            "devices": [ "nc220_pf" ],
             "configuration": {
               "cool-down": 30,
               "get-aer":     [ "setpci -s %s ECAP_AER+0x08.L",
@@ -556,20 +556,20 @@
         "rsu": [
           {
             "enabled": true,
-            "devices": [ "n6001_pf" ],
+            "devices": [ "nc220_pf" ],
             "fpga_default_sequences": "common_rsu_sequences"
           }
         ],
         "fpgareg": [
           {
             "enabled": true,
-            "devices": [ "n6001_pf", "n6001_vf" ]
+            "devices": [ "nc220_pf", "nc220_vf" ]
           }
         ],
         "opae.io": [
           {
             "enabled": true,
-            "devices": [ "n6001_pf", "n6001_vf" ]
+            "devices": [ "nc220_pf", "nc220_vf" ]
           }
         ]
       }
@@ -786,7 +786,7 @@
     "n5013",
     "n5014",
     "n6000",
-    "n6001",
+    "nc220",
     "c6100",
     "ofs",
     "f5"
diff --git a/opae.spec.fedora b/opae.spec.fedora
index f38e9fc7..305cb58f 100644
--- a/opae.spec.fedora
+++ b/opae.spec.fedora
@@ -222,6 +222,7 @@ done
 %{_libdir}/opae/libboard_d5005.so
 %{_libdir}/opae/libboard_n5010.so
 %{_libdir}/opae/libboard_n6000.so
+%{_libdir}/opae/libboard_nc220.so
 %{_libdir}/opae/libboard_c6100.so
 
 %{_bindir}/fpgad
diff --git a/opae.spec.in b/opae.spec.in
index 4d729ab2..9de99835 100644
--- a/opae.spec.in
+++ b/opae.spec.in
@@ -189,6 +189,7 @@ ldconfig
 @CMAKE_INSTALL_PREFIX@/@OPAE_LIB_INSTALL_DIR@/opae/libboard_n5010.so*
 @CMAKE_INSTALL_PREFIX@/@OPAE_LIB_INSTALL_DIR@/opae/libboard_a10gx.so*
 @CMAKE_INSTALL_PREFIX@/@OPAE_LIB_INSTALL_DIR@/opae/libboard_n6000.so*
+@CMAKE_INSTALL_PREFIX@/@OPAE_LIB_INSTALL_DIR@/opae/libboard_nc220.so*
 @CMAKE_INSTALL_PREFIX@/@OPAE_LIB_INSTALL_DIR@/opae/libboard_c6100.so*
 
 
diff --git a/opae.spec.rhel b/opae.spec.rhel
index 4835baca..5afdbc46 100644
--- a/opae.spec.rhel
+++ b/opae.spec.rhel
@@ -185,6 +185,7 @@ done
 %{_libdir}/opae/libboard_d5005.so
 %{_libdir}/opae/libboard_n5010.so
 %{_libdir}/opae/libboard_n6000.so
+%{_libdir}/opae/libboard_nc220.so
 %{_libdir}/opae/libboard_c6100.so
 
 %{_bindir}/fpgad
diff --git a/packaging/opae/deb/opae.install b/packaging/opae/deb/opae.install
index 93b3c03e..bc5d6e5f 100644
--- a/packaging/opae/deb/opae.install
+++ b/packaging/opae/deb/opae.install
@@ -25,6 +25,7 @@ usr/lib/opae/libboard_n3000.so
 usr/lib/opae/libboard_d5005.so
 usr/lib/opae/libboard_n5010.so
 usr/lib/opae/libboard_n6000.so
+usr/lib/opae/libboard_nc220.so
 usr/lib/opae/libboard_c6100.so
 usr/bin/fpgad
 usr/bin/fpgaconf
diff --git a/python/opae.admin/opae/admin/config.py b/python/opae.admin/opae/admin/config.py
index 92a8bce0..307b42dd 100644
--- a/python/opae.admin/opae/admin/config.py
+++ b/python/opae.admin/opae/admin/config.py
@@ -130,12 +130,21 @@ DEFAULT_FPGAREG_CONFIG = {
   (0x8086, 0xbccf, 0x8086, 0x1770) : {
     'platform': 'Intel Acceleration Development Platform N6000'
   },
+
+  #(0x8086, 0xbcce, 0x8086, 0x1771) : {
+  #  'platform': 'Intel Acceleration Development Platform N6001'
+  #},
+  #(0x8086, 0xbccf, 0x8086, 0x1771) : {
+  #  'platform': 'Intel Acceleration Development Platform N6001'
+  #},
+
   (0x8086, 0xbcce, 0x8086, 0x1771) : {
-    'platform': 'Intel Acceleration Development Platform N6001'
+    'platform': 'Intel Open FPGA Stack Platform NC220'
   },
   (0x8086, 0xbccf, 0x8086, 0x1771) : {
-    'platform': 'Intel Acceleration Development Platform N6001'
+    'platform': 'Intel Open FPGA Stack Platform NC220'
   },
+
   (0x8086, 0xbcce, 0x8086, 0x17d4): {
     'platform': 'Intel IPU Platform F2000X-PL'
   },
